[toc]

# 连续时间模型

## 布朗运动的模拟

```rust
use rand::Rng;
use rand_distr::StandardNormal;
use std::io;

fn main() -> io::Result<()> {
    println!("Enter the length of time(T):");
    let mut t_input = String::new();
    io::stdin().read_line(&mut t_input)?;
    let t: f64 = t_input.trim().parse().expect("please enter a valid number");

    println!("Enter the time perod(N)");
    let mut n_input= String::new();
    io::stdin().read_line(&mut n_input)?;
    let n: usize = n_input
        .trim()
        .parse()
        .expect("please enter a valid integer");

    let dt = t / n as f64;
    let sqrdt = dt.sqrt();

    let mut rng = rand::rng();
    let mut brownian_motion = 0.0;
    for i in 1..=n {
        let time = i as f64 * dt;

        let random_increment:f64 = rng.sample(StandardNormal);
        brownian_motion += random_increment * sqrdt;

        println!("{:<10.3} {:<10.6}", time, brownian_motion);
    }

    Ok(())
}

```



## 二阶变差

==为什么对布朗运动这样一个具有奇怪数学性质的过程感兴趣？==

原因在于资产定价从根本上要涉及到鞅（一个随时间变化的随机变量，其改变量的数学期望总是等于0），这一点已经反映在基本定价公式：
$$
Y(t)=S(t)E_t^S[\frac{Y(T)}{S(T)}]
$$
此外，连续过程（路径是时间的连续函数）比包含瞬间跳跃的过程在数学上更容易处理。更为重要的是，连续过程给出的数学模型比包含跳的过程更容易实现对冲。

因此，我们需要研究连续鞅过程，而任何不等于常数的鞅过程的总变差（该变量的绝对值的和）都是无穷的，这是鞅过程的一个重要结论。所以，在对连续鞅的研究中，不能采用我们熟悉的那些函数。



==在连续鞅过程中，为什么又要将研究集中在布朗运动上呢？==

任何一个连续鞅过程实际上只是布朗运动的一种变换。这个结论可以从Levy定理推出：

<u>一个连续鞅过程是布朗运动的充分必要条件是，在时间区间[0,T]上的二阶变差等于T。</u>

因此，布朗运动是[0,T]上二阶变差等于T的连续鞅过程。这实际上是一种标准化，不同的连续鞅过程会有不同的二阶变差，但经过改变时间尺度总可以把鞅过程转换为布朗运动。此外，很多连续鞅过程都可以看做是由关于布朗运动的“随机积分”构造出来的。

## ito过程

$$
dX(t)=\mu(t)dt+\sigma(t)dB(t) \tag{2.1}
$$

形如上式的Ito过程只有在$\mu=0$时才是鞅过程。

因为过程X变化量的期望值等于$\mu(t)dt$，而一个过程只有在改变量的期望等于0时才能成为鞅过程。这个结论是**推导资产定价公式的基础**。

对于一个Ito过程：
$$
\mu=0 \quad + \quad \mathbb{E}[\int^T_0 \sigma^2(t)dt]<\infty =\text{连续鞅过程} \tag{2.2}
$$
在给定0时信息条件下，时间T处的方差为
$$
var[X(T)]=\mathbb{E}[\int^T_0 \sigma^2(t)dt]<\infty
$$
*不管$\mu$是否等于0*，Ito过程X的二阶变差都以概率1等于
$$
\lim_{N \rightarrow \infty}\sum^N_{i=0}[\Delta X(t_i)]^2=\int^T_0\sigma^2(t)dt \tag{2.3}
$$
这一结论不依赖条件(2.2)。

计算二阶变差的简易法则（不严谨）：
$$
(dt)^2=0 \tag{2.4a}  
$$

$$
(dt)(dB)=0 \tag{2.4b}
$$

$$
(dB)^2=dt \tag{2.4c}
$$

二次变差更严格的数学标记：
$$
<X,X>(T)=\int^T_0 d<X,X>(t)=\int^T_0\sigma^2(t)dt \tag{2.5}
$$

## 伊藤公式

令$Y=g(B)$，则对Y进行二阶泰勒展开：
$$
\Delta Y \approx g'(B(t))\Delta B + \frac{1}{2}g''(B(t))[\Delta B]^2
$$
得到:
$$
\begin{align}
Y(T)&=Y(0)+\sum^N_{i=1}\Delta Y(t_i)\\
&\approx Y(0)+\sum^N_{i=1}g'(B(t_{i-1}))\Delta B(t_{i})+\frac{1}{2}\sum^N_{i=1}g''(B(t_{i-1}))[\Delta B(t_i)]^2
\end{align} \tag{2.8}
$$
取极限，可到伊藤公式：
$$
Y(T)=Y(0)+\int^T_0g'(B(t))dB(t)+\frac{1}{2}\int^T_0g''(B(t))dt \tag{2.7}
$$
比较：

普通函数像一辆平稳行驶的汽车，知道它的速度和方向（一阶导数）就足以预测未来的位置。

布朗运动像一辆剧烈且随机颠簸的汽车，要预测它的位置，你不仅要知道它的速度（一阶导数），还必须考虑它颠簸的剧烈程度（二阶导数，即曲率或波动率），因为这种颠簸本身会产生显著的位移。伊藤公式就是同时考虑了这两种效应的“预测公式”。

## 多维Ito过程

两个伊藤过程：
$$
dX(t)=\mu_x(t)dt+\sigma_x(t)dB_x(t) \tag{2.9a}
$$

$$
dY(t)=\mu_y(t)dt+\sigma_y(t)dB_y(t) \tag{2.9b}
$$

如果存在过程$\rho$（可能是随机过程），使得给定t时信息条件下两个正态随机变量的协方差可以表示为：
$$
E_t[\int^u_t\rho(s)ds]
$$
过程$\rho$称为两个布朗运动的相关系数。

注：即两个布朗运动增量该区间的“平均关联程度”的量化。



给定区间[0,T]上一个逐渐细化的划分$0=t_0<t_1<\cdots <t_N=T$，则当$N\rightarrow \infty$时，以概率1有：
$$
\sum^N_{i=1}\Delta B_x(t_i)\times \Delta B_y(t_i) \longrightarrow \int^T_0\rho(t)dt
$$
即可得到法则：
$$
(dB_x)(dB_y)=\rho dt
$$
可进一步证明：
$$
\begin{align}
	\lim_{N\rightarrow \infty}\sum^N_{i=1}\Delta X(t_i)\times \Delta Y(t_i)&=\int^T_0(dX)(dY)\\
	&=\int^T_0(\mu_xdt+\sigma_xdB_x)(\mu_ydt+\sigma_ydB_y)\\
	&=\int^T_0\sigma_x(t)\sigma_y(t)\rho(t)dt
\end{align}
$$
Ito公式的最一般形式，是函数$Z(t)=g(t,X(t),Y(t))$的Ito公式：
$$
Z(T)=Z(0)+\int^T_0\frac{\partial{g}}{\partial{t}}dt+\int^T_0\frac{\partial{g}}{\partial{x}}dX(t)+\int^T_0\frac{\partial{g}}{\partial{y}}dY(t)+\\
\frac{1}{2}\int^T_0\frac{\partial^2{g}}{\partial{x^2}}(dX(t))^2+\frac{1}{2}\int^T_0\frac{\partial^2{g}}{\partial{y^2}}(dY(t))^2 \\
+\int^T_0\frac{\partial^2{g}}{\partial{x}\partial{y}}(dX(t))(dY(t)) \tag{2.13}
$$
微分形式：
$$
dZ=\frac{\partial{g}}{\partial{t}}dt+\frac{\partial{g}}{\partial{x}}dX(t)+\frac{\partial{g}}{\partial{y}}dY(t)+\\
\frac{1}{2}\frac{\partial^2{g}}{\partial{x^2}}(dX(t))^2+\frac{1}{2}\frac{\partial^2{g}}{\partial{y^2}}(dY(t))^2 \\
+\frac{\partial^2{g}}{\partial{x}\partial{y}}(dX(t))(dY(t)) \tag{2.14}
$$

## 伊藤公式的几个法则

将式（2.14）中的函数分别取为$g(x,y)=xy,g(x,y)=y/x,g(x)=e^x,g(x)=\log x$

+ 乘积法则

  如果$Z=XY$,则
  $$
  dZ=XdY+YdX+(dX)(dY)
  $$
  等价于
  $$
  \frac{dZ}{Z}=\frac{dX}{X}+\frac{dY}{Y}+(\frac{dX}{X})(\frac{dY}{Y}) \tag{2.15}
  $$

+ 比值法则

  如果 $Z=Y/X$ ， 则
  $$
  \frac{dZ}{Z}=\frac{dY}{Y}-\frac{dX}{X}-(\frac{dY}{Y})(\frac{dX}{X})+(\frac{dX}{X})^2 \tag{2.16}
  $$
  

+ 指数法则

  如果$Z=e^X$ ， 则
  $$
  \frac{dZ}{Z}=dX+\frac{(dX)^2}{2} \tag{2.17}
  $$

+ 对数法则

  如果 $Z=\ln X$ ， 则
  $$
  dZ=\frac{dX}{X}-\frac{1}{2}(\frac{dX}{X})^2 \tag{2.18}
  $$

+ 复利/折现法则

  设
  $$
  Y(t)=\exp(\int^t_0 q(s)ds)
  $$
  其中q是一个过程（可以是随机过程）。对任何Ito过程，定义$Z=XY$。

  用普通微积分法则得出$dY(t)=q(t)Y(t)dt$，让上面给出的乘法法则得出
  $$
  \frac{dZ}{Z}=qdt+\frac{dX}{X} \tag{2.19}
  $$
  解释：

  虽然被积函数 *q*(*s*)可以是随机的，但**积分变量是普通的时间 ds，而不是布朗运动的微分dB(s) **

  **对每个“实现”或“路径”应用普通微积分**：

  - 我们可以这样理解：大自然首先“抽取”了一条特定的随机过程 *q*(*t*)的样本路径。对于这条特定的路径，*q*(*s*,*ω*)就变成了一个关于时间 *s*的**普通函数**（可能非常不规则，但它是确定的）。
  - 对于这个确定的被积函数，我们对时间 *s*进行积分，$∫_0^tq(s)ds$，结果是一个关于时间 *t*的**光滑函数**（因为积分对时间有平滑作用）。
  - 然后，我们对这个光滑的函数取指数，得到的 *Y*(*t*)关于时间 *t*也是一个**光滑函数**。

  在 $Y(t)$的定义中，完全没有出现 $dB(t)$。所有的随机性都被“锁”在了被积函数 *q*(*s*)里，而积分算子将$ds$其“驯化”了。**伊藤积分仅在与$dB(t)$打交道时才需要**。

## 红利再投资

结论：假定衍生证券的标的资产以“不变红利支付率”q支付红利，如果将得到的红利进行再投资购买标的资产，则标的资产数量会以q的指数增长。

证明：

考虑一个投资组合开始时由一份资产组成，持有该资产到T，其间的红利进行再投资。设$X(t)$表示该投资组合中股票的份数，$t\leq T$，则在时间t得到的红利为$qS(t)X(t)dt$，用红利可以购买的新股票数为$qX(t)dt$。由此得出$dX(t)=qX(t)dt$，或者$dX(t)/dt=qX(t)$，容易验证该微分方程的解为$X(t)=e^{qt}X(0)$，其中$X(0)=1$。由此得出$X(t)=e^{qt}$。

因为所支付红利进行了再投资，因此$V(t)$是不支付红利的投资组合价值。即：**持有并进行股息再投资的支付股息证券 `S(t)`，在价值上完全等价于持有一个人造的、不支付股息但价值为 $V(t) = e^{qt}S(t)$的证券**

在金融建模（尤其是期权定价）中，处理不支付股息的资产（如不派息的股票）的模型要简单得多。这个等价关系允许我们将复杂的支付股息资产的问题，转化为我们已熟知如何解决的、更简单的无股息资产问题。

这个等价关系的价值增长率：
$$
\frac{dS}{S}=qdt+\frac{dS}{S} \tag{2.20}
$$
即投资者的收益率等于红利支付率加上资本利得收益。

## 几何布朗运动

$$
S(t)=S(0)\exp(\mu t-\sigma^2t/2+\sigma B(t)) \tag{2.21}
$$

其中$\mu$和$\sigma$为常数，$B$为布朗运动。采用乘积法则和指数法则得出：
$$
\frac{dS}{S}=\mu dt+\sigma dB \tag{2.22}
$$
(2.21)是(2.22)的解。

把（2.22）解释为在dt瞬间，S的期望变化率为$\mu dt$，变化率方差为$\sigma^2 dt$。

将（2.21）取自然对数，得出另一种等价形式
$$
\log S(t)=\log S(0)+(\mu-\frac{1}{2}\sigma^2)t+\sigma B(t) \tag{2.23}
$$
微分形式为：
$$
d\log S(t)=(\mu-\frac{1}{2}\sigma^2)dt+\sigma dB(t) \tag{2.24}
$$
因此，（2.22）和（2.24）等价：
$$
\frac{dS}{S}=\mu dt+\sigma dB \quad  \Leftrightarrow \quad d\log S(t)=(\mu-\frac{1}{2}\sigma^2)dt+\sigma dB(t)
$$


又
$$
\frac{S(t_i)}{S(t_{i-1})}=e^{r_i\Delta t} \quad \Longrightarrow \quad\Delta \log S=r_i\Delta t \quad \Longrightarrow \quad r_i=\mu-\frac{1}{2}\sigma^2+\frac{\sigma\Delta B}{\Delta t}
$$
这说明 $r_i \sim \mathcal{N}(\mu-\frac{1}{2}\sigma^2,\sigma^2/\Delta t)$

如果给出收益率的历史数据，采用标准的估计方法可以估计出参数$\mu$和$\sigma$



模拟路径

```rust
use rand::Rng;
use rand_distr::StandardNormal;
use std::io;
fn main() ->io::Result<()>{
    println!("Enter the time range(T):");
    let mut T_input=String::new();
    io::stdin().read_line(&mut T_input)?;
    let t:f64=T_input.trim().parse().expect("Please type a number!");

    println!("Enter the time period(N):");
    let mut N_input=String::new();
    io::stdin().read_line(&mut N_input)?;
    let n:usize=N_input.trim().parse().expect("Please type a integar!");

    println!("Enter the S0:");
    let mut S_input=String::new();
    io::stdin().read_line(&mut S_input)?;
    let s:f64=S_input.trim().parse().expect("Please type a number!");

    println!("Enter the mu:");
    let mut mu_input=String::new();
    io::stdin().read_line(&mut mu_input)?;
    let mu:f64=mu_input.trim().parse().expect("Please type a number!");

    println!("Enter the sigma:");
    let mut sigma_input=String::new();
    io::stdin().read_line(&mut sigma_input)?;
    let sigma:f64=sigma_input.trim().parse().expect("Please type a number!");

    let time=t / n as f64;
    let sqrtime=time.sqrt();
    let mut logS=s.ln();
    println!("{:<10.3} {:<10.6}", 0 as f64, s);
    let mut rng=rand::rng();
    for i in 1..=n{
        let cur=i as f64 *time;

        let r=rng.sample::<f64,StandardNormal>(StandardNormal);
        logS+=(mu-0.5*sigma*sigma)*time+sigma*sqrtime*r;
        println!("{:<10.3} {:<10.6}", cur, logS.exp());
    }

    Ok(())
}
```


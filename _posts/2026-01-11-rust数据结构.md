[toc]

# 单链表的实现

## 带有头节点的单链表的实现

```rust
use std::fmt::Display;
use std::cmp::PartialEq;

#[derive(Debug)]
struct Node<T> {
    elem: T,
    next: Option<Box<Node<T>>>,
}

#[derive(Debug)]
pub struct SentinelLinkedList<T> {
    head: Box<Node<T>>, // 哨兵节点
}

// 泛型约束：必须的4个trait，缺一不可
impl<T: Display + Copy + Default + PartialEq> SentinelLinkedList<T> {
    pub fn new() -> Self {
        SentinelLinkedList {
            head: Box::new(Node {
                elem: T::default(),
                next: None,
            }),
        }
    }

    // ✅ 尾插法 - 无报错写法
    pub fn push_back(&mut self, elem: T) {
        let mut curr = &mut self.head;
        while curr.next.is_some() {
            curr = curr.next.as_mut().unwrap();
        }
        curr.next = Some(Box::new(Node { elem, next: None }));
    }

    // ✅ 头插法 - 永远无报错
    pub fn push_front(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem,
            next: self.head.next.take(),
        });
        self.head.next = Some(new_node);
    }

    // ✅ ✅ ✅ 【终极修复】remove方法 - 100%无E0506，无unsafe，所有权转移写法
    pub fn remove(&mut self, elem: T) -> bool {
        let mut curr = &mut self.head;
        // 遍历到尾部为止
        while curr.next.is_some() {
            // 核心关键：take() 拿走 curr.next 的所有权，原地留 None，彻底解除所有借用绑定
            let mut node = curr.next.take().unwrap();
            
            if node.elem == elem {
                // ✅ 直接赋值，无任何借用冲突！因为curr.next已经是None，无任何借用
                curr.next = node.next;
                return true;
            } else {
                // ✅ 不是目标节点，把节点塞回去，继续遍历
                curr.next = Some(node);
                // 安全转移可变引用，继续下一轮
                curr = curr.next.as_mut().unwrap();
            }
        }
        // 遍历完没找到，返回false
        false
    }

    // ✅ 打印链表 - 无报错
    pub fn print_list(&self) {
        let mut curr = &self.head.next;
        if curr.is_none() {
            println!("链表为空");
            return;
        }
        print!("哨兵链表：");
        while let Some(node) = curr {
            print!("{} -> ", node.elem);
            curr = &node.next;
        }
        println!("None");
    }
}

// 测试代码 - 全部运行正常
fn main() {
    let mut list = SentinelLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_front(0);
    list.print_list(); // 哨兵链表：0 -> 1 -> 2 -> None
    list.remove(1);
    list.print_list(); // 哨兵链表：0 -> 2 -> None
    list.remove(0);
    list.print_list(); // 哨兵链表：2 -> None
    list.remove(2);
    list.print_list(); // 链表为空
}
```

## 没有头节点的单链表实现

```rust
use std::fmt::Display;

/// 定义单链表的节点结构
#[derive(Debug)]
struct Node<T> {
    // 节点存储的数据
    elem: T,
    // 指向下一个节点的指针，Box拥有所有权，Option表示可选（None代表链表尾部）
    next: Option<Box<Node<T>>>,
}

/// 定义单链表结构，只持有头节点
#[derive(Debug)]
pub struct LinkedList<T> {
    head: Option<Box<Node<T>>>,
}

impl<T: Display + Copy> LinkedList<T> {
    /// 关联函数：创建一个空链表
    pub fn new() -> Self {
        LinkedList { head: None }
    }

    /// 头插法：在链表头部添加元素，时间复杂度 O(1)
    pub fn push_front(&mut self, elem: T) {
        // 创建新节点，新节点的next指向原链表的头节点
        let new_node = Box::new(Node {
            elem,
            next: self.head.take(), // take() 拿走Option的值，原地留下None，转移所有权
        });
        // 链表头节点更新为新节点
        self.head = Some(new_node);
    }

    /// 尾插法：在链表尾部添加元素，时间复杂度 O(n)
    pub fn push_back(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem,
            next: None,
        });

        // 指针从头节点开始遍历，需要可变引用
        let mut curr = &mut self.head;
        // 遍历到链表尾部（next为None的位置）
        while let Some(node) = curr {
            curr = &mut node.next;
        }
        // 在尾部插入新节点
        *curr = Some(new_node);
    }

    /// 按索引获取元素（只读，返回Option），索引从0开始
    pub fn get(&self, index: usize) -> Option<&T> {
        let mut curr = &self.head;
        let mut curr_idx = 0;

        while let Some(node) = curr {
            if curr_idx == index {
                return Some(&node.elem);
            }
            curr = &node.next;
            curr_idx += 1;
        }
        // 索引越界返回None
        None
    }

    /// 删除链表的头节点，并返回被删除的元素，时间复杂度 O(1)
    pub fn pop_front(&mut self) -> Option<T> {
        // take() 转移头节点的所有权
        self.head.take().map(|node| {
            // 将头节点更新为原头节点的后继节点
            self.head = node.next;
            // 返回被删除节点的数据
            node.elem
        })
    }

    /// 获取链表的长度，时间复杂度 O(n)
    pub fn len(&self) -> usize {
        let mut curr = &self.head;
        let mut count = 0;
        while let Some(node) = curr {
            count += 1;
            curr = &node.next;
        }
        count
    }

    /// 判断链表是否为空
    pub fn is_empty(&self) -> bool {
        self.head.is_none()
    }

    /// 清空链表，所有权回收
    pub fn clear(&mut self) {
        self.head = None;
    }

    /// 遍历链表并打印所有元素
    pub fn print_list(&self) {
        if self.is_empty() {
            println!("链表为空");
            return;
        }
        let mut curr = &self.head;
        print!("链表元素：");
        while let Some(node) = curr {
            print!("{} -> ", node.elem);
            curr = &node.next;
        }
        println!("None");
    }
}

// 测试代码
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_linked_list() {
        let mut list = LinkedList::new();
        assert!(list.is_empty());
        assert_eq!(list.len(), 0);

        // 头插法添加元素
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);
        list.print_list(); // 3 -> 2 -> 1 -> None
        assert_eq!(list.len(), 3);
        assert_eq!(list.get(0), Some(&3));
        assert_eq!(list.get(1), Some(&2));
        assert_eq!(list.get(2), Some(&1));
        assert_eq!(list.get(3), None); // 越界

        // 尾插法添加元素
        list.push_back(4);
        list.print_list(); // 3 -> 2 -> 1 ->4 -> None
        assert_eq!(list.len(),4);
        assert_eq!(list.get(3), Some(&4));

        // 删除头节点
        assert_eq!(list.pop_front(), Some(3));
        list.print_list(); // 2 ->1 ->4 -> None
        assert_eq!(list.len(),3);

        // 清空链表
        list.clear();
        assert!(list.is_empty());
        assert_eq!(list.pop_front(), None);
    }
}
```


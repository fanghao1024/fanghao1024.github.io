\---

layout: post

title: "rustå¸¸ç”¨åº“å‡½æ•°åŠæ–¹æ³•å°æ‘˜"

description: "è®°å½•æ—¥å¸¸å·¥ä½œå­¦ä¹ ä¸­ç¢°åˆ°è¿‡çš„rustçš„ä¸€äº›å¸¸ç”¨æ–¹æ³•ï¼Œæ–¹ä¾¿æŸ¥é˜…"

author:   "Hao"

category: true

tagline: "rust changes the world"

tags: [programming ,algorithm,rust]

\---

[toc]

# éšæœºæ•°ç”Ÿæˆ

```rust
/*
	cargo add rand
	cargo add rand_distr
*/
// å¼•å…¥å¿…è¦çš„ trait å’Œå‡½æ•°
use rand::Rng;
use rand_distr::StandardNormal;

fn main() {
    // è·å–å½“å‰çº¿ç¨‹çš„éšæœºæ•°ç”Ÿæˆå™¨
    //rngæ˜¯random number generatorçš„é¦–å­—æ¯
    let mut rng = rand::rng();

    // ä½¿ç”¨è¯¥ç”Ÿæˆå™¨å®ä¾‹çš„æ–¹æ³•æ¥äº§ç”Ÿéšæœºæ•°
    let num: i32 = rng.gen(); // ç”Ÿæˆä¸€ä¸ªé»˜è®¤ç±»å‹çš„éšæœºæ•°
    let dice_roll = rng.gen_range(1..=6); // ç”Ÿæˆä¸€ä¸ª1åˆ°6ï¼ˆåŒ…å«ï¼‰ä¹‹é—´çš„æ•´æ•°
    let rand_increment:f64=rng.sample(rand_distr::StandardNormal); //ç”Ÿæˆæ­£æ€åˆ†å¸ƒçš„éšæœºæ•°
}

```

# äºŒåˆ†æŸ¥æ‰¾

`partition_point`æ–¹æ³•æ˜¯å®ç° `lower_bound`å’Œ `upper_bound`åŠŸèƒ½æœ€ç›´æ¥å’Œæ¨èçš„æ–¹å¼ã€‚å®ƒæ¥æ”¶ä¸€ä¸ªè°“è¯ï¼ˆè¿”å› `bool`çš„é—­åŒ…ï¼‰ï¼Œå¹¶è¿”å›åˆ‡ç‰‡ä¸­**ç¬¬ä¸€ä¸ªä½¿è¯¥è°“è¯è¿”å› `false`**çš„å…ƒç´ çš„ç´¢å¼•

## ç±»ä¼¼C++çš„lower_bound

æŸ¥æ‰¾ç¬¬ä¸€ä¸ª**å¤§äºç­‰äº**ç›®æ ‡å€¼çš„å…ƒç´ ä½ç½®ã€‚

è°“è¯æ¡ä»¶æ˜¯åˆ¤æ–­å…ƒç´ æ˜¯å¦**å°äº**ç›®æ ‡å€¼ã€‚è¿”å›çš„ä½ç½®å°±æ˜¯ç¬¬ä¸€ä¸ªâ€œä¸å°äºâ€ï¼ˆå³å¤§äºç­‰äºï¼‰ç›®æ ‡å€¼çš„ä½ç½®

```rust
let nums = vec![1, 2, 3, 3, 4];
let target = 3;

// æŸ¥æ‰¾ç¬¬ä¸€ä¸ª >= target çš„å…ƒç´ çš„ä½ç½® (lower_bound)
let lower = nums.partition_point(|&x| x < target);
println!("Lower bound of {} is at index: {}", target, lower); // è¾“å‡º 2
```

## ç±»ä¼¼C++çš„upper_bound

```rust
// æŸ¥æ‰¾ç¬¬ä¸€ä¸ª > target çš„å…ƒç´ çš„ä½ç½® (upper_bound)
let upper = nums.partition_point(|&x| x <= target);
println!("Upper bound of {} is at index: {}", target, upper); // è¾“å‡º 4
```

## æ’å…¥æ“ä½œ

```rust
let j = g.partition_point(|&x| x < h);
if j < g.len() {
    g[j] = h;
} else {
    g.push(h);
}
```



# sort_byæŒ‰æ¡ä»¶æ’åº

`sort_by(|a, b| ...)`ä¸­çš„é—­åŒ…ï¼Œå…¶æ ¸å¿ƒä»»åŠ¡æ˜¯å›ç­”ä¸€ä¸ªé—®é¢˜ï¼š**ç›¸å¯¹äº `a`ï¼Œ`b`çš„é¡ºåºæ˜¯ä»€ä¹ˆï¼Ÿ**æˆ–è€…æ›´ç›´ç™½åœ°è¯´ï¼š**åœ¨æœ€ç»ˆçš„æ’åºç»“æœä¸­ï¼Œ`b`åº”è¯¥å‡ºç°åœ¨ `a`çš„å‰é¢è¿˜æ˜¯åé¢ï¼Ÿ**

- å½“é—­åŒ…è¿”å› `Ordering::Less`æ—¶ï¼Œè¡¨ç¤ºç¬¬ä¸€ä¸ªå‚æ•°ï¼ˆaï¼‰åº”è¯¥æ’åœ¨ç¬¬äºŒä¸ªå‚æ•°(b)**ä¹‹å‰**ã€‚
- åœ¨ `a.cmp(b)`ä¸­ï¼Œå¦‚æœ `a`å°äº `b`ï¼Œåˆ™è¿”å› `Less`ï¼Œæ‰€ä»¥ `a`ä¼šæ’åœ¨ `b`å‰é¢ï¼Œå½¢æˆé€’å¢ã€‚
- åœ¨ `b.cmp(a)`ä¸­ï¼Œå¦‚æœ `b`å°äº `a`ï¼Œåˆ™è¿”å› `Less`ï¼Œæ‰€ä»¥ `a`ä¼šæ’åœ¨ `b`å‰é¢ï¼Œè¿™ç›¸å½“äºæŠŠå¤§çš„æ•°å¾€å‰æ”¾ï¼Œå½¢æˆé€’å‡ã€‚

æ‰€ä»¥ï¼Œæ•´ä¸ªä»£ç  `tasks.sort_by(|a, b| b.cmp(a))`çš„å·¥ä½œæµç¨‹æ˜¯ï¼š

1. æ’åºç®—æ³•æ¯æ¬¡å–å‡ºé›†åˆä¸­çš„ä¸¤ä¸ªå…ƒç´ ï¼Œåˆ†åˆ«ä½œä¸ºé—­åŒ…çš„å‚æ•° `a`å’Œ `b`ã€‚
2. é—­åŒ…æ‰§è¡Œ `b.cmp(a)`ï¼Œä¹Ÿå°±æ˜¯åˆ¤æ–­ **`b`ç›¸å¯¹äº `a`çš„é¡ºåº**ã€‚
3. å¦‚æœ `b`æ¯” `a`å¤§ï¼ˆå³ `b.cmp(a)`è¿”å› `Ordering::Greater`ï¼‰ï¼Œæ’åºç®—æ³•å°±ä¼šè®¤ä¸º `a`åº”è¯¥æ’åœ¨ `b`çš„åé¢ï¼Œä»è€Œå®ç°äº†**ä»å¤§åˆ°å°**çš„é™åºæ’åˆ—ã€‚

```rust
let mut v = [5, 4, 1, 3, 2];
// é™åºæ’åº
v.sort_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]); // ç»“æœæ˜¯ä»å¤§åˆ°å°
```

## ä¸€ç§é”™è¯¯ä½¿ç”¨

```rust
pub fn erase_overlap_intervals(intervals: Vec<Vec<i32>>) -> i32 {
        let n=intervals.len();
        let mut intervals=intervals;
        intervals.sort_by(|&a,&b|a[1].cmp(&b[1])); //è¿™é‡Œåº”è¯¥æ”¹ä¸º|a,b|
        let mut rec=1;
        let mut preed=intervals[0][1];
        for i in 1..n{
            if intervals[i][0]>=preed{
                rec+=1;
                preed=intervals[i][1];
            }
        }
        (n-rec) as i32
    }
```

è¯´æ˜ï¼š

1. **é—­åŒ…å‚æ•°çš„æ¨¡å¼åŒ¹é…é—®é¢˜**ï¼š

- **é—­åŒ…è·å¾—çš„æ˜¯å¼•ç”¨**ï¼šå½“ä½ çš„é—­åŒ…è¢« `sort_by`è¿™æ ·çš„é«˜é˜¶å‡½æ•°è°ƒç”¨æ—¶ï¼Œè¯¥é«˜é˜¶å‡½æ•°ä¼ é€’ç»™é—­åŒ…çš„æ˜¯é›†åˆä¸­å…ƒç´ çš„**å¼•ç”¨**ï¼ˆåœ¨ä½ çš„ä»£ç ä¸­å°±æ˜¯ `&Vec<i32>`ï¼‰ã€‚æ‰€ä»¥ï¼Œæ— è®ºä½ å¦‚ä½•å†™é—­åŒ…çš„å‚æ•°åˆ—è¡¨ï¼Œé—­åŒ…å®é™…æ¥æ”¶åˆ°çš„æ˜¯ä¸€ä¸ªå¼•ç”¨ã€‚ä½¿ç”¨ `|a, b|`æ—¶ï¼Œ`a`å’Œ `b`ç›´æ¥å°±æ˜¯è¿™ä¸¤ä¸ªå¼•ç”¨ `&Vec<i32>`ã€‚ä½¿ç”¨ `|&a, &b|`æ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…ï¼Œä½ æ˜¯åœ¨å‘Šè¯‰ Rustï¼š"æˆ‘æœŸæœ›æ¥æ”¶åˆ°çš„å‚æ•°æ˜¯å¼•ç”¨ï¼Œå¹¶ä¸”è¯·è‡ªåŠ¨è§£æ„è¿™ä¸ªå¼•ç”¨ï¼Œå°†å…¶å†…éƒ¨çš„å€¼ç»‘å®šåˆ°å˜é‡ `a`å’Œ `b`ä¸Š"ã€‚
- **é—®é¢˜çš„æ ¹æºï¼šç§»åŠ¨é Copy ç±»å‹**ï¼šè§£æ„ä¸€ä¸ªå¼•ç”¨ï¼ˆ`&Vec<i32>`ï¼‰å¹¶è¯•å›¾å°†å…¶å†…éƒ¨çš„å€¼ï¼ˆ`Vec<i32>`ï¼‰ç»‘å®šåˆ°æ–°å˜é‡ï¼ˆ`a`, `b`ï¼‰ä¸Šï¼Œæ„å‘³ç€ä½ éœ€è¦å°† `Vec<i32>`ä»å¼•ç”¨èƒŒå**ç§»åŠ¨**å‡ºæ¥ã€‚ä½†æ˜¯ï¼ŒRust ä¸å…è®¸ä½ é€šè¿‡ä¸€ä¸ªå…±äº«å¼•ç”¨ï¼ˆ`&T`ï¼‰æ¥ç§»åŠ¨å…¶æŒ‡å‘çš„æ•°æ®ï¼Œå› ä¸ºä½ å¹¶ä¸æ‹¥æœ‰è¯¥æ•°æ®çš„æ‰€æœ‰æƒã€‚è¿™å°±æ˜¯ç¼–è¯‘å™¨æŠ¥é”™ "cannot move out of a shared reference" çš„åŸå› ã€‚åªæœ‰å½“ç±»å‹å®ç°äº† `Copy`traitï¼ˆä¾‹å¦‚ç®€å•çš„æ•´æ•°ã€æµ®ç‚¹æ•°ï¼‰ï¼ŒRust æ‰ä¼šåœ¨è§£æ„æ—¶è‡ªåŠ¨è¿›è¡Œå¤åˆ¶è€Œä¸æ˜¯ç§»åŠ¨ï¼Œè¿™æ ·æ“ä½œæ‰æ˜¯å®‰å…¨çš„ã€‚è€Œ `Vec<i32>`æ²¡æœ‰å®ç° `Copy`trait ã€‚

2. **å¯¹æ¯”ç®€å•ç±»å‹**ï¼š

   å¦‚æœç±»å‹å®ç°äº† `Copy`ï¼ˆå¦‚ `i32`ï¼‰ï¼Œæ¨¡å¼åŒ¹é… `|&a, &b|`æ˜¯å…è®¸çš„ï¼Œå› ä¸ºè§£æ„æ—¶ä¼šå¤åˆ¶å€¼è€Œéç§»åŠ¨ã€‚ä½† `Vec<i32>`ä¸æ”¯æŒå¤åˆ¶ï¼Œåªèƒ½ç§»åŠ¨ï¼Œä»è€Œè§¦å‘æ‰€æœ‰æƒè§„åˆ™æ£€æŸ¥ã€‚

3. ä¸ºä»€ä¹ˆä¿®æ”¹ä¸º|a,b|æœ‰æ•ˆ

   - `sort_by`æ–¹æ³•ä¼šå‘é—­åŒ…ä¼ é€’**å…ƒç´ çš„å¼•ç”¨**ï¼ˆå³ `&Vec<i32>`ï¼‰ã€‚
   - ç›´æ¥ä½¿ç”¨ `|a, b|`åï¼Œ`a`å’Œ `b`ä¿æŒä¸ºå¼•ç”¨ç±»å‹ï¼Œé€šè¿‡ `a[1]`å’Œ `b[1]`è®¿é—®å…ƒç´ æ—¶ï¼ŒRust ä¼šè‡ªåŠ¨è§£å¼•ç”¨ï¼ˆDeref coercionï¼‰ï¼Œè€Œä¸ä¼šè§¦å‘æ‰€æœ‰æƒç§»åŠ¨ã€‚
   - ç”±äºä¸æ¶‰åŠç§»åŠ¨ï¼Œç¼–è¯‘å™¨ä¸å†æŠ¥é”™

4. cmpå‡½æ•°é‡Œä¸ºä»€ä¹ˆåˆåŠ äº†å¼•ç”¨.cmp(&b[1])

   `cmp`æ–¹æ³•ï¼ˆå±äº `i32`ç±»å‹ï¼‰çš„å®šä¹‰æ˜¯ `fn cmp(&self, other: &Self) -> Ordering`ã€‚å®ƒéœ€è¦çš„æ˜¯å¯¹ä¸¤ä¸ªè¦æ¯”è¾ƒçš„å€¼çš„**å¼•ç”¨**ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ `&`æ¥è·å– `b[1]`è¿™ä¸ª `i32`å€¼çš„å¼•ç”¨ã€‚

å®¹æ˜“æ··æ·†çš„åœ°æ–¹ï¼š

å¯¹äºä¸€ä¸ªå¼•ç”¨ç±»å‹b(æ¯”å¦‚bæ˜¯&Vec<i32>)ï¼Œ`b`å’Œ `b[1]`ç¡®å®æ˜¯ä¸¤ç§ä¸åŒçš„ä¸œè¥¿ã€‚

ç®€å•æ¥è¯´ï¼š**`b`æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼ˆæŒ‡å‘æ•´ä¸ª `Vec`ï¼‰ï¼Œè€Œ `b[1]`æ˜¯é€šè¿‡ç´¢å¼•æ“ä½œä» `b`æ‰€æŒ‡å‘çš„å‘é‡ä¸­å–å‡ºçš„ä¸€ä¸ªå…·ä½“çš„å€¼ï¼ˆ`i32`ï¼‰**ã€‚

ä¸‹é¢è¿™ä¸ªè¡¨æ ¼æ¸…æ™°åœ°å±•ç¤ºäº†ä¸¤è€…çš„æ ¸å¿ƒåŒºåˆ«ï¼š

|        ç‰¹æ€§        | `b`ï¼ˆé—­åŒ…å‚æ•°ï¼‰                    | `b[1]`ï¼ˆç´¢å¼•æ“ä½œç»“æœï¼‰                                    |
| :----------------: | ---------------------------------- | --------------------------------------------------------- |
|    **å®é™…ç±»å‹**    | `&Vec<i32>`ï¼ˆå¼•ç”¨ï¼‰                | `i32`ï¼ˆå€¼ï¼‰                                               |
|      **æœ¬è´¨**      | ä¸€ä¸ªâ€œæŒ‡é’ˆâ€ï¼ŒæŒ‡å‘å‘é‡æ•°æ®çš„å†…å­˜åœ°å€ | å‘é‡ä¸­å­˜å‚¨çš„å…·ä½“çš„æ•´æ•°å€¼                                  |
|     **æ‰€æœ‰æƒ**     | ä¸æ‹¥æœ‰æ•°æ®çš„æ‰€æœ‰æƒï¼ˆå€Ÿç”¨ï¼‰         | å¯¹äº `i32`è¿™ç§å®ç°äº† `Copy`çš„ç±»å‹ï¼Œä½ ä¼šå¾—åˆ°è¯¥å€¼çš„ä¸€ä¸ªå‰¯æœ¬ |
| **å¦‚ä½•ç”¨äº `cmp`** | é€šè¿‡ `b[1]`è®¿é—®å…¶å…ƒç´               | éœ€è¦å–å…¶å¼•ç”¨ `&b[1]`ä»¥åŒ¹é… `cmp`ç­¾å                      |

| åœºæ™¯                  | å‘é‡ç±»å‹ (`intervals`) | é—­åŒ…å‚æ•° (`a`, `b`) ç±»å‹ | ç´¢å¼•æ“ä½œ (`a[1]`) ç»“æœç±»å‹ | æ¨èçš„æ¯”è¾ƒå†™æ³•    |
| :-------------------- | :--------------------- | :----------------------- | :------------------------- | :---------------- |
| **å…ƒç´ ä¸º `i32`**      | `Vec<Vec<i32>>`        | `&Vec<i32>`              | `i32`(å€¼)                  | `a[1].cmp(&b[1])` |
| **å…ƒç´ ä¸º `Vec<i32>`** | `Vec<Vec<Vec<i32>>>`   | `&Vec<Vec<i32>>`         | `&Vec<i32>`(å¼•ç”¨)          | `a[1].cmp(b[1])`  |

# ç»“æ„ä½“æ’åº

```rust
//envelopes: mut Vec<Vec<i32>>
envelopes.sort_unstable_by_key(|e| (e[0], -e[1]));
```

# æœ€å°å †çš„å®ç°
rustçš„BinaryHeapé»˜è®¤å®ç°æœ€å¤§å †ï¼Œå¦‚æœè¦å»ºç«‹æœ€å°å †ï¼Œå¯ä»¥ä½¿ç”¨ Reverse åŒ…è£…å™¨ï¼Œstd::cmp::Reverse æ˜¯ä¸€ä¸ªç®€å•çš„åŒ…è£…å™¨ç»“æ„ä½“ï¼Œå®ƒä¼šåè½¬å…¶å†…éƒ¨å€¼çš„æ’åºé¡ºåºã€‚
## åŸç†
å½“ä½ å°†ä¸€ä¸ªå…ƒç´  T åŒ…è£…åœ¨ Reverse<T> ä¸­æ—¶ï¼ŒReverse<T> çš„ Ord å®ç°ä¼šè°ƒç”¨ T çš„ Ord å®ç°ï¼Œä½†ä¼šè¿”å›ç›¸åçš„ç»“æœã€‚
a.cmp(b) è¿”å› Ordering::Lessï¼Œé‚£ä¹ˆ Reverse(a).cmp(&Reverse(b)) å°±ä¼šè¿”å› Ordering::Greaterã€‚
è¿™æ ·ä¸€æ¥ï¼ŒBinaryHeap åœ¨æ¯”è¾ƒ Reverse å…ƒç´ æ—¶ï¼Œå°±ä¼šæŠŠæœ€å°çš„åŸå§‹å…ƒç´ å½“æˆ â€œæœ€å¤§â€ çš„ Reverse å…ƒç´ ï¼Œä»è€Œå°†å…¶æ”¾åœ¨å †é¡¶ã€‚
## å®ç°
```rust

use std::collections::BinaryHeap;
use std::cmp::Reverse;

fn main() {
    // åˆ›å»ºä¸€ä¸ªå­˜å‚¨ Reverse<i32> çš„ BinaryHeap
    let mut min_heap = BinaryHeap::new();

    // æ’å…¥å…ƒç´ æ—¶ï¼Œç”¨ Reverse åŒ…è£…èµ·æ¥
    min_heap.push(Reverse(3));
    min_heap.push(Reverse(1));
    min_heap.push(Reverse(2));

    println!("æœ€å°å †å¼¹å‡ºé¡ºåºï¼š");
    while let Some(Reverse(num)) = min_heap.pop() {
        println!("{}", num); // è¾“å‡ºé¡ºåºï¼š1, 2, 3
    }
}

```

```rust
//ç”¨æœ€å°å †å®ç°éœå¤«æ›¼æ ‘
use std::collections::BinaryHeap;
use std::cmp::Reverse;
impl Solution {
    pub fn min_build_time(blocks: Vec<i32>, split: i32) -> i32 {
        let n=blocks.len();
        let mut pqu=BinaryHeap::new();
        for i in 0..n{
            pqu.push(Reverse(blocks[i]));
        }
        while pqu.len()>1{
            let a=pqu.pop().unwrap().0;
            let b=pqu.pop().unwrap().0;
            pqu.push(Reverse(split+std::cmp::max(a,b)));
        }
        pqu.pop().unwrap().0
    }
}

```
# é—­åŒ…
+ Fné—­åŒ…
  é€šè¿‡==å¼•ç”¨==æ•è·å˜é‡ï¼Œä¸å¯å˜å€Ÿç”¨ã€‚
+ FnMuté—­åŒ…
  é€šè¿‡==å¯å˜å¼•ç”¨==æ•è·å˜é‡ï¼Œå¯å˜å€Ÿç”¨ã€‚
+ FnOnceé—­åŒ…
  é€šè¿‡==å€¼==æ•è·å˜é‡ï¼Œæ‰€æœ‰æƒè½¬ç§»ã€‚

```rust
fn main(){
    let x=5;
    let y=10;

    //Fné—­åŒ…ï¼šé€šè¿‡å¼•ç”¨æ•è·å˜é‡
    let add = |a| a+x;

    //FnMuté—­åŒ…ï¼šé€šè¿‡å¯å˜å¼•ç”¨æ•è·å˜é‡
    let mut multiply = |a|{
        a/y
    };

    //FnOnceé—­åŒ…ï¼šé€šè¿‡å€¼æ•è·å˜é‡
    let divide = move |a|{
    a/y
    };
}

```

# å¤šçº¿ç¨‹
## spawnåˆ›å»ºçº¿ç¨‹
```rust
use std::{thread,time::Duration,Builder};

fn main(){
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    //Threadä¹Ÿæ”¯æŒé€šè¿‡std::thread::Builderç»“æ„ä½“è¿›è¡Œåˆ›å»ºï¼ŒBuilderæä¾›äº†ä¸€äº›çº¿ç¨‹çš„é…ç½®é¡¹

    let handle=Builder::new()
        .name("my_thread".to_string()) //çº¿ç¨‹å
        .stack_size(1024*4)    //è®¾ç½®çº¿ç¨‹çš„å †æ ˆå¤§å°æ˜¯1024*4
        .spawn({
            "hello world" //ç›¸å½“äºå­çº¿ç¨‹çš„æ‰§è¡Œç»“æœå°±æ˜¯å­—ç¬¦ä¸²"hello world"
        });
    let res=handle.join().unwrap();  //é˜»æ­¢å½“å‰çº¿ç¨‹ï¼ˆä¸»çº¿ç¨‹ï¼‰æ‰§è¡Œï¼Œç­‰å¾…å­çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œå¾—åˆ°å­çº¿ç¨‹çš„æ‰§è¡Œç»“æœï¼Œå³"hello world"

}


```
çº¿ç¨‹ä¸­ä½¿ç”¨äº†å…¶ä»–çº¿ç¨‹çš„å˜é‡æ˜¯ä¸åˆæ³•çš„ï¼Œå¿…é¡»ä½¿ç”¨moveè¡¨æ˜çº¿ç¨‹æ‹¥æœ‰dataçš„æ‰€æœ‰æƒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨moveå…³é”®å­—æŠŠdataçš„æ‰€æœ‰æƒè½¬ç§»åˆ°å­çº¿ç¨‹å†…ã€‚
```rust
use std::thread;

fn main(){
    let data=String::from("hello world");
    let thread=std::thread::spawn(move ||{  //ä½¿ç”¨moveæŠŠdataçš„æ‰€æœ‰æƒè½¬åˆ°çº¿ç¨‹å†…
        println!("{}",data);
    });
    thread.join();

    let v=vec![1,3,5,7,9];
    let mut childs=vec![];
    for n in v{
        let c=thread::spawn(move ||{
            println!("{}",n*n);
        });
        childs.push(c);
    }
    for c in childs{
        c.join().unwrap();  //ç­‰å¾…æ‰€æœ‰å­è¿›ç¨‹ç»“æŸï¼Œæˆ–è€…ä½¿ç”¨expectæ–¹æ³•æ¥è·å–è¿”å›å€¼
    }
}

```
moveé—­åŒ…é€šå¸¸å’Œthread::spawnå‡½æ•°ä¸€èµ·ä½¿ç”¨ï¼Œå®ƒå…è®¸ç”¨æˆ·ä½¿ç”¨å…¶ä»–çº¿ç¨‹çš„æ•°æ®ï¼Œè¿™æ ·åœ¨åˆ›å»ºæ–°çº¿ç¨‹æ—¶ï¼Œå¯ä»¥æŠŠå…¶ä»–çº¿ç¨‹ä¸­çš„å˜é‡çš„æ‰€æœ‰æƒä»ä¸€ä¸ªçº¿ç¨‹è½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œç„¶åå°±å¯ä»¥ä½¿ç”¨æ”¹å˜é‡äº†ã€‚
## å¾—åˆ°å½“å‰ç³»ç»Ÿçš„é»˜è®¤å¹¶è¡Œåº¦
```rust
use std::{io,thread};
fn main() ->io::Result<()>{
    let count=thread::available_parallelism()?.get();
    assert!(count>=1_usize);
    println!("{},{}",count,1_usize);
    Ok(())
}
```
## çº¿ç¨‹é—´é€šä¿¡
```rust

use std::sync::{Arc,Mutex};
use std::thread;

fn main() {
    let counter=Arc::new(Mutex::new(0));
    let mut handles=vec![];

    for _ in 0..10{
        let counter=Arc::clone(&counter);
        let handle=thread::spawn(move||{
            let mut num=counter.lock().unwrap();
            *num+=1;
        });
        handles.push(handle);
    }

    for handle in handles{
        handle.join().unwrap();
    }

    println!("result: {}",*counter.lock().unwrap());
}

```

# æ ‡å‡†è¾“å…¥è¾“å‡ºå’Œå‘½ä»¤è¡Œå‚æ•°

std::ioæ¨¡å—

è¯¥æ¨¡å—æœ€æ ¸å¿ƒçš„éƒ¨åˆ†æ˜¯Readå’ŒWriteä¸¤ä¸ªtraitã€‚

trait Readç”¨äºè¯»ï¼›Writeç”¨äºå‘è¾“å‡ºæµä¸­å†™å…¥æ•°æ®ï¼ŒåŒ…å«å­—èŠ‚æ•°æ®å’ŒUTF-8æ•°æ®ä¸¤ç§æ ¼å¼ã€‚

## ä»æ ‡å‡†è¾“å…¥æµä¸­è¯»å–æ•°æ®

ä¸€èˆ¬ä¸ç›´æ¥ä½¿ç”¨trait Readï¼Œè€Œæ˜¯é€šè¿‡å®ç°å„ä¸ªå­traitæä¾›ç»™ç”¨æˆ·ä½¿ç”¨ã€‚

rustè¯­è¨€çš„Stdinå®è´¨ä¸Šæ˜¯"BufReader<StdinRaw>"çš„çº¿ç¨‹å®‰å…¨ç‰ˆã€‚

å‡½æ•°std::io::stdin()è¿”å›ä¸€ä¸ªstd::Stdinçš„å®ä¾‹ï¼Œè¿™æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œä»£è¡¨æ ‡å‡†è¾“å…¥æµã€‚æ³¨æ„ï¼šå‡½æ•°stdin()ä¸­çš„sæ˜¯å°å†™çš„ï¼Œè€Œç»“æ„ä½“Stdinä¸­çš„S æ˜¯å¤§å†™çš„ã€‚

std::ioæ˜¯æ ‡å‡†åº“ä¸­å…³äºè¾“å…¥è¾“å‡ºçš„åŒ…ï¼Œæ ‡å‡†åº“æä¾›çš„std::io::stdin()ä¼šè¿”å›å½“å‰è¿›ç¨‹çš„æ ‡å‡†è¾“å…¥æµstdinçš„å¥æŸ„ã€‚è€Œread_line()åˆ™æ˜¯æ ‡å‡†è¾“å…¥æµstdinçš„å¥æŸ„ä¸Šçš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºä»æ ‡å‡†è¾“å…¥æµè¯»å–ä¸€è¡Œæ•°æ®ã€‚read_line()æ–¹æ³•çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªResultæšä¸¾ï¼Œè€Œunwrap()åˆ™æ˜¯ç”¨äºç®€åŒ–å¯æ¢å¤é”™è¯¯çš„å¤„ç†ï¼Œå®ƒä¼šè¿”å›Resultä¸­å­˜å‚¨çš„å®é™…å€¼ã€‚

```rust
use std::io;

fn myf(){
    //ä¸€è¡Œæœ‰å¤šä¸ªæ•°
    let mut buf = String::new();
    io::stdin().read_line(&mut buf).unwrap();
    let mut nums=buf.split_whitespace();
    let num1:f64=nums.next().unwrap().parse().unwrap();
    let num2:f64=nums.next().unwrap().parse().unwrap();
    let num3:f64=nums.next().unwrap().parse().unwrap();
    
    //è¯»å…¥æ•°ç»„
    let mut buf=String::new();
    io::stdin().read_line(&mut buf).unwrap();
    let ns:Vec<i32>=buff.split_whitespace().map(|x| x.parse().unwrap()).collect();
    for v in ns{
        print!("{} ",v);
    }
}

fn main(){
    let mut buf=String::new();
    io::stdin().read_line(&mut buf).unwrap();
    let num1:i32=buf.trim().parse().unwrap();
    println!("{}",num1);
    
    myf();
}
```



å¦‚æœæœ‰å¤šä¸ªæ ‡å‡†è¾“å…¥æµå®ä¾‹ï¼Œåˆ™é€šè¿‡äº’æ–¥é”è¿›è¡ŒåŒæ­¥ã€‚

```rust
use std::io::{self,BufRead}
fn main()->io::Result<()>{
    let mut buffer=String::new();
    let mystdin=io::stdin();
    let mut handle=stdin.lock();  //æ˜¾å¼äº’æ–¥
    
    handle.read_line(&mut buffer);
    Ok(())
}


use std::io;
fn main()->io::Result<()>{
    let mut buffer=String::new();
    io::stdion().read_line(&mut buffer)ï¼› //éšå¼åŒæ­¥è¯»å–å†…å®¹
    Ok(())
}
```

ç›®å‰Rustæ ‡å‡†åº“è¿˜æ²¡æœ‰æä¾›ç›´æ¥ä»å‘½ä»¤è¡Œè¯»å–æ•°å­—æˆ–æ ¼å¼åŒ–æ•°æ®çš„æ–¹æ³•ã€‚

## æ ‡å‡†è¾“å‡ºæµ

std::io::stdout() ä¼šè¿”å› std::io::Stdoutç»“æ„ä½“ï¼Œè¡¨ç¤ºæ ‡å‡†è¾“å‡ºæµã€‚ç»“æ„ä½“Sdtoutå®ç°äº†Write traitã€‚å‡½æ•°stdoutæ˜¯æ¨¡å—std::ioçš„ä¸€ä¸ªæˆå‘˜å‡½æ•°ï¼Œä¸ºå½“å‰è¿›ç¨‹çš„æ ‡å‡†è¾“å‡ºåˆ›å»ºä¸€ä¸ªæ–°çš„å®ä¾‹ï¼Œè¿”å›çš„æ˜¯å¥æŸ„Stdoutï¼Œè¿™ä¸ªå¥æŸ„å°±æ˜¯å½“å‰è¿›ç¨‹çš„æ ‡å‡†è¾“å‡ºæµçš„å¥æŸ„ã€‚stdoutå‡½æ•°è¿”å›çš„æ¯ä¸ªå¥æŸ„éƒ½æ˜¯å¯¹å…±äº«ç¼“å†²åŒºçš„å¼•ç”¨ï¼Œå› æ­¤å¯¹è¯¥ç¼“å†²åŒºçš„è®¿é—®é€šè¿‡äº’æ–¥é”è¿›è¡ŒåŒæ­¥ã€‚

éšå¼åŒæ­¥ï¼š

```rust
use std::io::{self,Write};

fn main()->io::Result<()>{
    io::stdout().write_all(b"hello world")?;
    Ok(())
}
```

æ˜¾å¼åŒæ­¥ï¼š

```rust
use std::io::{self,Write};

fn main()->io::Result<()>{
    let stdout=io::stdout();
    let mut handle=stdout.lock();
    handle.write_all(b"hello world")?;
    Ok(())
}
```

â€œæ ‡å‡†è¾“å‡ºâ€é€šå¸¸å°±æ˜¯æŒ‡ç»ˆç«¯å±å¹•ï¼Œè€Œâ€œæ ‡å‡†è¾“å…¥â€ä¸€èˆ¬å°±æ˜¯æŒ‡é”®ç›˜ã€‚

write()æ˜¯æ ‡å‡†è¾“å‡ºæµstdoutçš„å¥æŸ„ä¸Šçš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºå‘æ ‡å‡†è¾“å‡ºæµå†™å…¥==å­—èŠ‚æµå†…å®¹==ã€‚

```rust
use std::io::Write;
fn main(){
    std::io::stdout().write("http".as_bytes()).unwrap();
}
```

##  å‘½ä»¤è¡Œå‚æ•°

Rustè¯­è¨€åœ¨æ ‡å‡†åº“ä¸­å†…ç½®äº†std::env::args()å‡½æ•°è¿”å›æ‰€æœ‰çš„å‘½ä»¤è¡Œå‚æ•°ï¼Œå…¶ç¬¬ä¸€é¡¹æ˜¯ç¨‹åºåã€‚

```rust
fn main(){
    let cmd_line=std::env::args();
    for arg in cmd_line{
        println!("{} ",arg);
    }
}
```

<<<<<<< Updated upstream
# æ¨¡å—åŒ–

æ–‡ä»¶ç»“æ„ï¼š

```plaintext
AC/
â”œâ”€â”€ Calc/                # åº“ crateï¼ˆè¢«è°ƒç”¨æ–¹ï¼‰
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ lib.rs       # å« pub fn European_Call
â”‚   â””â”€â”€ Cargo.toml
â””â”€â”€ Chapter5/
    â””â”€â”€ C5/              # äºŒè¿›åˆ¶ crateï¼ˆè°ƒç”¨æ–¹ï¼‰
        â”œâ”€â”€ src/
        â”‚   â””â”€â”€ main.rs  # è¦è°ƒç”¨ European_Call
        â””â”€â”€ Cargo.toml
```

## åœ¨è°ƒç”¨æ–¹ï¼ˆC5ï¼‰çš„ `Cargo.toml` ä¸­æ·»åŠ ä¾èµ–

å› ä¸º `Calc` æ˜¯æœ¬åœ° crateï¼Œéœ€ç”¨ `path` æŒ‡å®šç›¸å¯¹è·¯å¾„

```toml
[package]
name = "C5"
version = "0.1.0"
edition = "2021"

[dependencies]
# å…³é”®ï¼šæ·»åŠ å¯¹ Calc crate çš„ä¾èµ–
Calc = { path = "../../Calc" }  # è·¯å¾„ä» C5/Cargo.toml æŒ‡å‘ Calc/Cargo.toml
```

- è·¯å¾„å†™æ³•ï¼š`../../Calc` è¡¨ç¤º â€œå‘ä¸Šä¸¤å±‚åˆ° AC ç›®å½•ï¼Œå†è¿›å…¥ Calc ç›®å½•â€

## åœ¨ C5 çš„ `main.rs` ä¸­è°ƒç”¨å‡½æ•°

é€šè¿‡ `use` å¯¼å…¥ `Calc` ä¸­çš„å…¬å¼€å‡½æ•°ï¼Œæˆ–ç›´æ¥é€šè¿‡ `crateå::å‡½æ•°å` è°ƒç”¨ï¼š	

```rust
use Calc::European_Call;

fn main(){
    let call=European_Call(S,K,r,sigma,q,T);
    println!("{call:?}");
}
```

# åŒç«¯é˜Ÿåˆ—VecDequeçš„ä½¿ç”¨

Rustæ ‡å‡†åº“ä¸­çš„`VecDeque`æ˜¯ä¸€ä¸ªåŸºäºå¯å¢é•¿ç¯å½¢ç¼“å†²åŒºå®ç°çš„åŒç«¯é˜Ÿåˆ—ï¼Œå®ƒå…è®¸åœ¨é˜Ÿåˆ—çš„å¤´éƒ¨å’Œå°¾éƒ¨è¿›è¡Œé«˜æ•ˆçš„æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚ä»¥ä¸‹æ˜¯å…¶åŸºæœ¬ç”¨æ³•çš„è¯¦ç»†ä»‹ç»ã€‚

1.  ğŸš€ åˆ›å»º VecDeque

ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹å‡ ç§æ–¹å¼åˆ›å»ºä¸€ä¸ª`VecDeque`ï¼š

| æ–¹æ³•                         | è¯´æ˜                                | ç¤ºä¾‹ä»£ç                                           |
| ---------------------------- | ----------------------------------- | ------------------------------------------------- |
| `VecDeque::new()`            | åˆ›å»ºä¸€ä¸ªç©ºçš„`VecDeque`ã€‚            | `let mut deque: VecDeque<i32> = VecDeque::new();` |
| `VecDeque::with_capacity(n)` | åˆ›å»ºä¸€ä¸ªåˆå§‹å®¹é‡ä¸º`n`çš„`VecDeque`ã€‚ | `let mut deque = VecDeque::with_capacity(10);`    |
| `VecDeque::from([x, y, z])`  | ä»æ•°ç»„æˆ–å‘é‡ç›´æ¥è½¬æ¢åˆ›å»ºã€‚          | `let deq = VecDeque::from([1, 2, 3]);`            |

2.  â• æ·»åŠ å…ƒç´ 

`VecDeque`çš„æ ¸å¿ƒç‰¹æ€§æ˜¯æ”¯æŒåœ¨ä¸¤ç«¯é«˜æ•ˆæ·»åŠ å…ƒç´ ã€‚

- **åœ¨å°¾éƒ¨æ·»åŠ **ï¼šä½¿ç”¨ `push_back`æ–¹æ³•ã€‚
- **åœ¨å¤´éƒ¨æ·»åŠ **ï¼šä½¿ç”¨ `push_front`æ–¹æ³•ã€‚è¿™ä¸æ™®é€šé˜Ÿåˆ—ï¼ˆä»…æ”¯æŒå°¾éƒ¨æ·»åŠ ï¼‰ä¸åŒï¼Œæ˜¯å…¶â€œåŒç«¯â€èƒ½åŠ›çš„ä½“ç°ã€‚

```rust
use std::collections::VecDeque;

let mut deque = VecDeque::new();
deque.push_back('a'); // é˜Ÿåˆ—: [a]
deque.push_front('b'); // é˜Ÿåˆ—: [b, a]
deque.push_back('c'); // é˜Ÿåˆ—: [b, a, c]
```

3.  â– åˆ é™¤å…ƒç´ 

ç›¸åº”åœ°ï¼Œä½ ä¹Ÿå¯ä»¥ä»ä¸¤ç«¯ç§»é™¤å…ƒç´ ã€‚

- **ä»å°¾éƒ¨ç§»é™¤**ï¼šä½¿ç”¨ `pop_back`æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ª `Option<T>`ï¼Œå¦‚æœé˜Ÿåˆ—ä¸ºç©ºåˆ™è¿”å› `None`ã€‚
- **ä»å¤´éƒ¨ç§»é™¤**ï¼šä½¿ç”¨ `pop_front`æ–¹æ³•ï¼ŒåŒæ ·è¿”å› `Option<T>`ã€‚

```rust
let mut deque = VecDeque::from(['b', 'a', 'c']);
assert_eq!(deque.pop_front(), Some('b')); // ç§»é™¤å¹¶è¿”å›å¤´éƒ¨å…ƒç´  'b'
assert_eq!(deque.pop_back(), Some('c')); // ç§»é™¤å¹¶è¿”å›å°¾éƒ¨å…ƒç´  'c'
assert_eq!(deque.pop_back(), Some('a')); // ç§»é™¤å¹¶è¿”å›å°¾éƒ¨å…ƒç´  'a'
assert_eq!(deque.pop_back(), None); // é˜Ÿåˆ—å·²ç©ºï¼Œè¿”å› None
```

4.  ğŸ‘€ è®¿é—®å…ƒç´ 

ä½ å¯ä»¥å®‰å…¨åœ°æŸ¥çœ‹æˆ–è·å–é˜Ÿåˆ—ä¸¤ç«¯çš„å…ƒç´ ï¼Œè€Œä¸ä¼šç§»é™¤å®ƒä»¬ã€‚

- **æŸ¥çœ‹å¤´éƒ¨å…ƒç´ **ï¼šä½¿ç”¨ `front()`æ–¹æ³•ï¼Œè¿”å› `Option<&T>`ã€‚
- **æŸ¥çœ‹å°¾éƒ¨å…ƒç´ **ï¼šä½¿ç”¨ `back()`æ–¹æ³•ï¼Œè¿”å› `Option<&T>`ã€‚
- **é€šè¿‡ç´¢å¼•è®¿é—®**ï¼šä½¿ç”¨ `get(index)`æ–¹æ³•è·å–æŒ‡å®šç´¢å¼•å¤„å…ƒç´ çš„ä¸å¯å˜å¼•ç”¨ï¼Œæˆ–ä½¿ç”¨ `get_mut(index)`è·å–å¯å˜å¼•ç”¨ã€‚ä½¿ç”¨ç´¢å¼•è¯­æ³• `deque[index]`åœ¨è¶Šç•Œæ—¶ä¼šç›´æ¥è§¦å‘ panicã€‚

```rust
let mut deque = VecDeque::from([10, 20, 30]);
// æŸ¥çœ‹å…ƒç´ 
assert_eq!(deque.front(), Some(&10));
assert_eq!(deque.back(), Some(&30));
// é€šè¿‡ç´¢å¼•è·å–å’Œä¿®æ”¹
if let Some(elem) = deque.get_mut(1) {
    *elem = 25; // å°†ç´¢å¼•1å¤„çš„å…ƒç´ ä»20ä¿®æ”¹ä¸º25
}
assert_eq!(deque[1], 25);
```

5.  ğŸ” å…¶ä»–å®ç”¨æ“ä½œ

`VecDeque`è¿˜æä¾›äº†ä¸€äº›å…¶ä»–å¸¸ç”¨æ–¹æ³•ï¼š

- **`len()`**: è¿”å›é˜Ÿåˆ—ä¸­çš„å…ƒç´ æ•°é‡ã€‚
- **`is_empty()`**: æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚
- **`swap(i, j)`**: äº¤æ¢ç´¢å¼• `i`å’Œ `j`å¤„çš„ä¸¤ä¸ªå…ƒç´ ã€‚
- **`clear()`**: æ¸…ç©ºé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
- **`iter()`**: è¿”å›ä¸€ä¸ªç”¨äºéå†é˜Ÿåˆ—å…ƒç´ çš„è¿­ä»£å™¨ã€‚

6. ğŸ’¡ æ ¸å¿ƒè¦ç‚¹ä¸ä½¿ç”¨åœºæ™¯

- **é«˜æ€§èƒ½**ï¼šåœ¨é˜Ÿåˆ—ä¸¤ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œéå¸¸é«˜æ•ˆã€‚ä½†å½“å®¹é‡ä¸è¶³éœ€è¦æ‰©å®¹æ—¶ï¼Œä¼šå‘ç”Ÿ O(n) çš„æ—¶é—´å¤æ‚åº¦æ“ä½œã€‚
- **é¢„åˆ†é…å®¹é‡**ï¼šå¦‚æœä½ èƒ½é¢„ä¼°é˜Ÿåˆ—çš„å¤§è‡´å¤§å°ï¼Œä½¿ç”¨ `VecDeque::with_capacity`æˆ– `reserve`æ–¹æ³•é¢„å…ˆåˆ†é…ç©ºé—´å¯ä»¥é¿å…åœ¨è¿è¡Œæ—¶å¤šæ¬¡æ‰©å®¹ï¼Œä»è€Œæå‡æ€§èƒ½ã€‚
- **é€‚ç”¨åœºæ™¯**ï¼š`VecDeque`éå¸¸é€‚åˆéœ€è¦åŒæ—¶ä½œä¸ºé˜Ÿåˆ—ï¼ˆFIFOï¼‰å’Œæ ˆï¼ˆLIFOï¼‰ä½¿ç”¨çš„åœºæ™¯ï¼Œæˆ–è€…éœ€è¦é¢‘ç¹åœ¨åºåˆ—ä¸¤ç«¯è¿›è¡Œæ“ä½œçš„ç®—æ³•ã€‚é€šå¸¸ï¼Œå®ƒæ¯”é“¾è¡¨ï¼ˆ`LinkedList`ï¼‰æœ‰æ›´å¥½çš„å†…å­˜å±€éƒ¨æ€§å’Œç¼“å­˜å‹å¥½æ€§ï¼Œæ˜¯æ›´æ¨èä½¿ç”¨çš„åŒç«¯æ•°æ®ç»“æ„ã€‚

å¸Œæœ›è¿™äº›ä»‹ç»èƒ½å¸®åŠ©ä½ å¿«é€Ÿä¸Šæ‰‹ Rust æ ‡å‡†åº“ä¸­çš„ `VecDeque`ã€‚å¦‚æœä½ å¯¹ç‰¹å®šæ–¹æ³•çš„ç»†èŠ‚æˆ–æ›´é«˜çº§çš„ç”¨æ³•ï¼ˆå¦‚èŒƒå›´æ“ä½œ `range_mut`æˆ–é˜Ÿåˆ—åˆå¹¶ `append`ç­‰ï¼‰æœ‰è¿›ä¸€æ­¥å…´è¶£ï¼Œæˆ‘å¯ä»¥ä¸ºä½ æä¾›æ›´è¯¦ç»†çš„è¯´æ˜ã€‚

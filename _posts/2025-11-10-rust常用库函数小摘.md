[toc]

# 随机数生成

```rust
/*
	cargo add rand
	cargo add rand_distr
*/
// 引入必要的 trait 和函数
use rand::Rng;
use rand_distr::StandardNormal;

fn main() {
    // 获取当前线程的随机数生成器
    //rng是random number generator的首字母
    let mut rng = rand::rng();
    
    // 使用该生成器实例的方法来产生随机数
    let num: i32 = rng.gen(); // 生成一个默认类型的随机数
    let dice_roll = rng.gen_range(1..=6); // 生成一个1到6（包含）之间的整数
    let rand_increment:f64=rng.sample(rand_distr::StandardNormal); //生成正态分布的随机数
}

```

# 二分查找

`partition_point`方法是实现 `lower_bound`和 `upper_bound`功能最直接和推荐的方式。它接收一个谓词（返回 `bool`的闭包），并返回切片中**第一个使该谓词返回 `false`**的元素的索引

## 类似C++的lower_bound

查找第一个**大于等于**目标值的元素位置。

谓词条件是判断元素是否**小于**目标值。返回的位置就是第一个“不小于”（即大于等于）目标值的位置

```rust
let nums = vec![1, 2, 3, 3, 4];
let target = 3;

// 查找第一个 >= target 的元素的位置 (lower_bound)
let lower = nums.partition_point(|&x| x < target);
println!("Lower bound of {} is at index: {}", target, lower); // 输出 2
```

## 类似C++的upper_bound

```rust
// 查找第一个 > target 的元素的位置 (upper_bound)
let upper = nums.partition_point(|&x| x <= target);
println!("Upper bound of {} is at index: {}", target, upper); // 输出 4
```

## 插入操作

```rust
let j = g.partition_point(|&x| x < h);
if j < g.len() {
    g[j] = h;
} else {
    g.push(h);
}
```



# sort_by按条件排序

`sort_by(|a, b| ...)`中的闭包，其核心任务是回答一个问题：**相对于 `a`，`b`的顺序是什么？**或者更直白地说：**在最终的排序结果中，`b`应该出现在 `a`的前面还是后面？**

- 当闭包返回 `Ordering::Less`时，表示第一个参数（a）应该排在第二个参数(b)**之前**。
- 在 `a.cmp(b)`中，如果 `a`小于 `b`，则返回 `Less`，所以 `a`会排在 `b`前面，形成递增。
- 在 `b.cmp(a)`中，如果 `b`小于 `a`，则返回 `Less`，所以 `a`会排在 `b`前面，这相当于把大的数往前放，形成递减。

所以，整个代码 `tasks.sort_by(|a, b| b.cmp(a))`的工作流程是：

1. 排序算法每次取出集合中的两个元素，分别作为闭包的参数 `a`和 `b`。
2. 闭包执行 `b.cmp(a)`，也就是判断 **`b`相对于 `a`的顺序**。
3. 如果 `b`比 `a`大（即 `b.cmp(a)`返回 `Ordering::Greater`），排序算法就会认为 `a`应该排在 `b`的后面，从而实现了**从大到小**的降序排列。

```rust
let mut v = [5, 4, 1, 3, 2];
// 降序排序
v.sort_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]); // 结果是从大到小
```

# 结构体排序

```rust
//envelopes: mut Vec<Vec<i32>>
envelopes.sort_unstable_by_key(|e| (e[0], -e[1]));
```

# 最小堆的实现
rust的BinaryHeap默认实现最大堆，如果要建立最小堆，可以使用 Reverse 包装器，std::cmp::Reverse 是一个简单的包装器结构体，它会反转其内部值的排序顺序。
## 原理
当你将一个元素 T 包装在 Reverse<T> 中时，Reverse<T> 的 Ord 实现会调用 T 的 Ord 实现，但会返回相反的结果。
a.cmp(b) 返回 Ordering::Less，那么 Reverse(a).cmp(&Reverse(b)) 就会返回 Ordering::Greater。
这样一来，BinaryHeap 在比较 Reverse 元素时，就会把最小的原始元素当成 “最大” 的 Reverse 元素，从而将其放在堆顶。
## 实现
```rust

use std::collections::BinaryHeap;
use std::cmp::Reverse;

fn main() {
    // 创建一个存储 Reverse<i32> 的 BinaryHeap
    let mut min_heap = BinaryHeap::new();

    // 插入元素时，用 Reverse 包装起来
    min_heap.push(Reverse(3));
    min_heap.push(Reverse(1));
    min_heap.push(Reverse(2));

    println!("最小堆弹出顺序：");
    while let Some(Reverse(num)) = min_heap.pop() {
        println!("{}", num); // 输出顺序：1, 2, 3
    }
}

```

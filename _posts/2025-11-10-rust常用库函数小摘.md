[toc]

# 随机数生成

```rust
/*
	cargo add rand
	cargo add rand_distr
*/
// 引入必要的 trait 和函数
use rand::Rng;
use rand_distr::StandardNormal;

fn main() {
    // 获取当前线程的随机数生成器
    //rng是random number generator的首字母
    let mut rng = rand::rng();

    // 使用该生成器实例的方法来产生随机数
    let num: i32 = rng.gen(); // 生成一个默认类型的随机数
    let dice_roll = rng.gen_range(1..=6); // 生成一个1到6（包含）之间的整数
    let rand_increment:f64=rng.sample(rand_distr::StandardNormal); //生成正态分布的随机数
}

```

# 二分查找

`partition_point`方法是实现 `lower_bound`和 `upper_bound`功能最直接和推荐的方式。它接收一个谓词（返回 `bool`的闭包），并返回切片中**第一个使该谓词返回 `false`**的元素的索引

## 类似C++的lower_bound

查找第一个**大于等于**目标值的元素位置。

谓词条件是判断元素是否**小于**目标值。返回的位置就是第一个“不小于”（即大于等于）目标值的位置

```rust
let nums = vec![1, 2, 3, 3, 4];
let target = 3;

// 查找第一个 >= target 的元素的位置 (lower_bound)
let lower = nums.partition_point(|&x| x < target);
println!("Lower bound of {} is at index: {}", target, lower); // 输出 2
```

## 类似C++的upper_bound

```rust
// 查找第一个 > target 的元素的位置 (upper_bound)
let upper = nums.partition_point(|&x| x <= target);
println!("Upper bound of {} is at index: {}", target, upper); // 输出 4
```

## 插入操作

```rust
let j = g.partition_point(|&x| x < h);
if j < g.len() {
    g[j] = h;
} else {
    g.push(h);
}
```



# sort_by按条件排序

`sort_by(|a, b| ...)`中的闭包，其核心任务是回答一个问题：**相对于 `a`，`b`的顺序是什么？**或者更直白地说：**在最终的排序结果中，`b`应该出现在 `a`的前面还是后面？**

- 当闭包返回 `Ordering::Less`时，表示第一个参数（a）应该排在第二个参数(b)**之前**。
- 在 `a.cmp(b)`中，如果 `a`小于 `b`，则返回 `Less`，所以 `a`会排在 `b`前面，形成递增。
- 在 `b.cmp(a)`中，如果 `b`小于 `a`，则返回 `Less`，所以 `a`会排在 `b`前面，这相当于把大的数往前放，形成递减。

所以，整个代码 `tasks.sort_by(|a, b| b.cmp(a))`的工作流程是：

1. 排序算法每次取出集合中的两个元素，分别作为闭包的参数 `a`和 `b`。
2. 闭包执行 `b.cmp(a)`，也就是判断 **`b`相对于 `a`的顺序**。
3. 如果 `b`比 `a`大（即 `b.cmp(a)`返回 `Ordering::Greater`），排序算法就会认为 `a`应该排在 `b`的后面，从而实现了**从大到小**的降序排列。

```rust
let mut v = [5, 4, 1, 3, 2];
// 降序排序
v.sort_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]); // 结果是从大到小
```

## 一种错误使用

```rust
pub fn erase_overlap_intervals(intervals: Vec<Vec<i32>>) -> i32 {
        let n=intervals.len();
        let mut intervals=intervals;
        intervals.sort_by(|&a,&b|a[1].cmp(&b[1])); //这里应该改为|a,b|
        let mut rec=1;
        let mut preed=intervals[0][1];
        for i in 1..n{
            if intervals[i][0]>=preed{
                rec+=1;
                preed=intervals[i][1];
            }
        }
        (n-rec) as i32
    }
```

说明：

1. **闭包参数的模式匹配问题**：

- **闭包获得的是引用**：当你的闭包被 `sort_by`这样的高阶函数调用时，该高阶函数传递给闭包的是集合中元素的**引用**（在你的代码中就是 `&Vec<i32>`）。所以，无论你如何写闭包的参数列表，闭包实际接收到的是一个引用。使用 `|a, b|`时，`a`和 `b`直接就是这两个引用 `&Vec<i32>`。使用 `|&a, &b|`是一种模式匹配，你是在告诉 Rust："我期望接收到的参数是引用，并且请自动解构这个引用，将其内部的值绑定到变量 `a`和 `b`上"。
- **问题的根源：移动非 Copy 类型**：解构一个引用（`&Vec<i32>`）并试图将其内部的值（`Vec<i32>`）绑定到新变量（`a`, `b`）上，意味着你需要将 `Vec<i32>`从引用背后**移动**出来。但是，Rust 不允许你通过一个共享引用（`&T`）来移动其指向的数据，因为你并不拥有该数据的所有权。这就是编译器报错 "cannot move out of a shared reference" 的原因。只有当类型实现了 `Copy`trait（例如简单的整数、浮点数），Rust 才会在解构时自动进行复制而不是移动，这样操作才是安全的。而 `Vec<i32>`没有实现 `Copy`trait 。

2. **对比简单类型**：

   如果类型实现了 `Copy`（如 `i32`），模式匹配 `|&a, &b|`是允许的，因为解构时会复制值而非移动。但 `Vec<i32>`不支持复制，只能移动，从而触发所有权规则检查。

3. 为什么修改为|a,b|有效

   - `sort_by`方法会向闭包传递**元素的引用**（即 `&Vec<i32>`）。
   - 直接使用 `|a, b|`后，`a`和 `b`保持为引用类型，通过 `a[1]`和 `b[1]`访问元素时，Rust 会自动解引用（Deref coercion），而不会触发所有权移动。
   - 由于不涉及移动，编译器不再报错

4. cmp函数里为什么又加了引用.cmp(&b[1])

   `cmp`方法（属于 `i32`类型）的定义是 `fn cmp(&self, other: &Self) -> Ordering`。它需要的是对两个要比较的值的**引用**。因此，我们需要用 `&`来获取 `b[1]`这个 `i32`值的引用。

容易混淆的地方：

对于一个引用类型b(比如b是&Vec<i32>)，`b`和 `b[1]`确实是两种不同的东西。

简单来说：**`b`是一个引用（指向整个 `Vec`），而 `b[1]`是通过索引操作从 `b`所指向的向量中取出的一个具体的值（`i32`）**。

下面这个表格清晰地展示了两者的核心区别：

|        特性        | `b`（闭包参数）                    | `b[1]`（索引操作结果）                                    |
| :----------------: | ---------------------------------- | --------------------------------------------------------- |
|    **实际类型**    | `&Vec<i32>`（引用）                | `i32`（值）                                               |
|      **本质**      | 一个“指针”，指向向量数据的内存地址 | 向量中存储的具体的整数值                                  |
|     **所有权**     | 不拥有数据的所有权（借用）         | 对于 `i32`这种实现了 `Copy`的类型，你会得到该值的一个副本 |
| **如何用于 `cmp`** | 通过 `b[1]`访问其元素              | 需要取其引用 `&b[1]`以匹配 `cmp`签名                      |

| 场景                  | 向量类型 (`intervals`) | 闭包参数 (`a`, `b`) 类型 | 索引操作 (`a[1]`) 结果类型 | 推荐的比较写法    |
| :-------------------- | :--------------------- | :----------------------- | :------------------------- | :---------------- |
| **元素为 `i32`**      | `Vec<Vec<i32>>`        | `&Vec<i32>`              | `i32`(值)                  | `a[1].cmp(&b[1])` |
| **元素为 `Vec<i32>`** | `Vec<Vec<Vec<i32>>>`   | `&Vec<Vec<i32>>`         | `&Vec<i32>`(引用)          | `a[1].cmp(b[1])`  |

# 结构体排序

```rust
//envelopes: mut Vec<Vec<i32>>
envelopes.sort_unstable_by_key(|e| (e[0], -e[1]));
```

# 最小堆的实现
rust的BinaryHeap默认实现最大堆，如果要建立最小堆，可以使用 Reverse 包装器，std::cmp::Reverse 是一个简单的包装器结构体，它会反转其内部值的排序顺序。
## 原理
当你将一个元素 T 包装在 Reverse<T> 中时，Reverse<T> 的 Ord 实现会调用 T 的 Ord 实现，但会返回相反的结果。
a.cmp(b) 返回 Ordering::Less，那么 Reverse(a).cmp(&Reverse(b)) 就会返回 Ordering::Greater。
这样一来，BinaryHeap 在比较 Reverse 元素时，就会把最小的原始元素当成 “最大” 的 Reverse 元素，从而将其放在堆顶。
## 实现
```rust

use std::collections::BinaryHeap;
use std::cmp::Reverse;

fn main() {
    // 创建一个存储 Reverse<i32> 的 BinaryHeap
    let mut min_heap = BinaryHeap::new();

    // 插入元素时，用 Reverse 包装起来
    min_heap.push(Reverse(3));
    min_heap.push(Reverse(1));
    min_heap.push(Reverse(2));

    println!("最小堆弹出顺序：");
    while let Some(Reverse(num)) = min_heap.pop() {
        println!("{}", num); // 输出顺序：1, 2, 3
    }
}

```

```rust
//用最小堆实现霍夫曼树
use std::collections::BinaryHeap;
use std::cmp::Reverse;
impl Solution {
    pub fn min_build_time(blocks: Vec<i32>, split: i32) -> i32 {
        let n=blocks.len();
        let mut pqu=BinaryHeap::new();
        for i in 0..n{
            pqu.push(Reverse(blocks[i]));
        }
        while pqu.len()>1{
            let a=pqu.pop().unwrap().0;
            let b=pqu.pop().unwrap().0;
            pqu.push(Reverse(split+std::cmp::max(a,b)));
        }
        pqu.pop().unwrap().0
    }
}

```
# 闭包
+ Fn闭包
  通过==引用==捕获变量，不可变借用。
+ FnMut闭包
  通过==可变引用==捕获变量，可变借用。
+ FnOnce闭包
  通过==值==捕获变量，所有权转移。

```rust
fn main(){
    let x=5;
    let y=10;

    //Fn闭包：通过引用捕获变量
    let add = |a| a+x;

    //FnMut闭包：通过可变引用捕获变量
    let mut multiply = |a|{
        a/y
    };

    //FnOnce闭包：通过值捕获变量
    let divide = move |a|{
    a/y
    };
}

```

# 多线程
## spawn创建线程
```rust
use std::{thread,time::Duration,Builder};

fn main(){
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    //Thread也支持通过std::thread::Builder结构体进行创建，Builder提供了一些线程的配置项

    let handle=Builder::new()
        .name("my_thread".to_string()) //线程名
        .stack_size(1024*4)    //设置线程的堆栈大小是1024*4
        .spawn({
            "hello world" //相当于子线程的执行结果就是字符串"hello world"
        });
    let res=handle.join().unwrap();  //阻止当前线程（主线程）执行，等待子线程执行完毕，得到子线程的执行结果，即"hello world"

}


```
线程中使用了其他线程的变量是不合法的，必须使用move表明线程拥有data的所有权，我们可以使用move关键字把data的所有权转移到子线程内。
```rust
use std::thread;

fn main(){
    let data=String::from("hello world");
    let thread=std::thread::spawn(move ||{  //使用move把data的所有权转到线程内
        println!("{}",data);
    });
    thread.join();

    let v=vec![1,3,5,7,9];
    let mut childs=vec![];
    for n in v{
        let c=thread::spawn(move ||{
            println!("{}",n*n);
        });
        childs.push(c);
    }
    for c in childs{
        c.join().unwrap();  //等待所有子进程结束，或者使用expect方法来获取返回值
    }
}

```
move闭包通常和thread::spawn函数一起使用，它允许用户使用其他线程的数据，这样在创建新线程时，可以把其他线程中的变量的所有权从一个线程转移到另一个线程，然后就可以使用改变量了。
## 得到当前系统的默认并行度
```rust
use std::{io,thread};
fn main() ->io::Result<()>{
    let count=thread::available_parallelism()?.get();
    assert!(count>=1_usize);
    println!("{},{}",count,1_usize);
    Ok(())
}
```
## 线程间通信
```rust

use std::sync::{Arc,Mutex};
use std::thread;

fn main() {
    let counter=Arc::new(Mutex::new(0));
    let mut handles=vec![];

    for _ in 0..10{
        let counter=Arc::clone(&counter);
        let handle=thread::spawn(move||{
            let mut num=counter.lock().unwrap();
            *num+=1;
        });
        handles.push(handle);
    }

    for handle in handles{
        handle.join().unwrap();
    }

    println!("result: {}",*counter.lock().unwrap());
}

```

# 标准输入输出和命令行参数

std::io模块

该模块最核心的部分是Read和Write两个trait。

trait Read用于读；Write用于向输出流中写入数据，包含字节数据和UTF-8数据两种格式。

## 从标准输入流中读取数据

一般不直接使用trait Read，而是通过实现各个子trait提供给用户使用。

rust语言的Stdin实质上是"BufReader<StdinRaw>"的线程安全版。

函数std::io::stdin()返回一个std::Stdin的实例，这是一个结构体，代表标准输入流。注意：函数stdin()中的s是小写的，而结构体Stdin中的S 是大写的。

std::io是标准库中关于输入输出的包，标准库提供的std::io::stdin()会返回当前进程的标准输入流stdin的句柄。而read_line()则是标准输入流stdin的句柄上的一个方法，用于从标准输入流读取一行数据。read_line()方法的返回值是一个Result枚举，而unwrap()则是用于简化可恢复错误的处理，它会返回Result中存储的实际值。

```rust
use std::io;

fn myf(){
    //一行有多个数
    let mut buf = String::new();
    io::stdin().read_line(&mut buf).unwrap();
    let mut nums=buf.split_whitespace();
    let num1:f64=nums.next().unwrap().parse().unwrap();
    let num2:f64=nums.next().unwrap().parse().unwrap();
    let num3:f64=nums.next().unwrap().parse().unwrap();
    
    //读入数组
    let mut buf=String::new();
    io::stdin().read_line(&mut buf).unwrap();
    let ns:Vec<i32>=buff.split_whitespace().map(|x| x.parse().unwrap()).collect();
    for v in ns{
        print!("{} ",v);
    }
}

fn main(){
    let mut buf=String::new();
    io::stdin().read_line(&mut buf).unwrap();
    let num1:i32=buf.trim().parse().unwrap();
    println!("{}",num1);
    
    myf();
}
```



如果有多个标准输入流实例，则通过互斥锁进行同步。

```rust
use std::io::{self,BufRead}
fn main()->io::Result<()>{
    let mut buffer=String::new();
    let mystdin=io::stdin();
    let mut handle=stdin.lock();  //显式互斥
    
    handle.read_line(&mut buffer);
    Ok(())
}


use std::io;
fn main()->io::Result<()>{
    let mut buffer=String::new();
    io::stdion().read_line(&mut buffer)； //隐式同步读取内容
    Ok(())
}
```

目前Rust标准库还没有提供直接从命令行读取数字或格式化数据的方法。

## 标准输出流

std::io::stdout() 会返回 std::io::Stdout结构体，表示标准输出流。结构体Sdtout实现了Write trait。函数stdout是模块std::io的一个成员函数，为当前进程的标准输出创建一个新的实例，返回的是句柄Stdout，这个句柄就是当前进程的标准输出流的句柄。stdout函数返回的每个句柄都是对共享缓冲区的引用，因此对该缓冲区的访问通过互斥锁进行同步。

隐式同步：

```rust
use std::io::{self,Write};

fn main()->io::Result<()>{
    io::stdout().write_all(b"hello world")?;
    Ok(())
}
```

显式同步：

```rust
use std::io::{self,Write};

fn main()->io::Result<()>{
    let stdout=io::stdout();
    let mut handle=stdout.lock();
    handle.write_all(b"hello world")?;
    Ok(())
}
```

“标准输出”通常就是指终端屏幕，而“标准输入”一般就是指键盘。

write()是标准输出流stdout的句柄上的一个方法，用于向标准输出流写入==字节流内容==。

```rust
use std::io::Write;
fn main(){
    std::io::stdout().write("http".as_bytes()).unwrap();
}
```

##  命令行参数

Rust语言在标准库中内置了std::env::args()函数返回所有的命令行参数，其第一项是程序名。

```rust
fn main(){
    let cmd_line=std::env::args();
    for arg in cmd_line{
        println!("{} ",arg);
    }
}
```

<<<<<<< Updated upstream
# 模块化

文件结构：

```plaintext
AC/
├── Calc/                # 库 crate（被调用方）
│   ├── src/
│   │   └── lib.rs       # 含 pub fn European_Call
│   └── Cargo.toml
└── Chapter5/
    └── C5/              # 二进制 crate（调用方）
        ├── src/
        │   └── main.rs  # 要调用 European_Call
        └── Cargo.toml
```

## 在调用方（C5）的 `Cargo.toml` 中添加依赖

因为 `Calc` 是本地 crate，需用 `path` 指定相对路径

```toml
[package]
name = "C5"
version = "0.1.0"
edition = "2021"

[dependencies]
# 关键：添加对 Calc crate 的依赖
Calc = { path = "../../Calc" }  # 路径从 C5/Cargo.toml 指向 Calc/Cargo.toml
```

- 路径写法：`../../Calc` 表示 “向上两层到 AC 目录，再进入 Calc 目录”

## 在 C5 的 `main.rs` 中调用函数

通过 `use` 导入 `Calc` 中的公开函数，或直接通过 `crate名::函数名` 调用：	

```rust
use Calc::European_Call;

fn main(){
    let call=European_Call(S,K,r,sigma,q,T);
    println!("{call:?}");
}
```

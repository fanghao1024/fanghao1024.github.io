[toc]

# 随机数生成

```rust
/*
	cargo add rand
	cargo add rand_distr
*/
// 引入必要的 trait 和函数
use rand::Rng;
use rand_distr::StandardNormal;

fn main() {
    // 获取当前线程的随机数生成器
    //rng是random number generator的首字母
    let mut rng = rand::rng();
    
    // 使用该生成器实例的方法来产生随机数
    let num: i32 = rng.gen(); // 生成一个默认类型的随机数
    let dice_roll = rng.gen_range(1..=6); // 生成一个1到6（包含）之间的整数
    let rand_increment:f64=rng.sample(rand_distr::StandardNormal); //生成正态分布的随机数
}

```

# 二分查找

`partition_point`方法是实现 `lower_bound`和 `upper_bound`功能最直接和推荐的方式。它接收一个谓词（返回 `bool`的闭包），并返回切片中**第一个使该谓词返回 `false`**的元素的索引

## 类似C++的lower_bound

查找第一个**大于等于**目标值的元素位置。

谓词条件是判断元素是否**小于**目标值。返回的位置就是第一个“不小于”（即大于等于）目标值的位置

```rust
let nums = vec![1, 2, 3, 3, 4];
let target = 3;

// 查找第一个 >= target 的元素的位置 (lower_bound)
let lower = nums.partition_point(|&x| x < target);
println!("Lower bound of {} is at index: {}", target, lower); // 输出 2
```

## 类似C++的upper_bound

```rust
// 查找第一个 > target 的元素的位置 (upper_bound)
let upper = nums.partition_point(|&x| x <= target);
println!("Upper bound of {} is at index: {}", target, upper); // 输出 4
```


[toc]

# 随机数生成

```rust
/*
	cargo add rand
	cargo add rand_distr
*/
// 引入必要的 trait 和函数
use rand::Rng;
use rand_distr::StandardNormal;

fn main() {
    // 获取当前线程的随机数生成器
    //rng是random number generator的首字母
    let mut rng = rand::rng();

    // 使用该生成器实例的方法来产生随机数
    let num: i32 = rng.gen(); // 生成一个默认类型的随机数
    let dice_roll = rng.gen_range(1..=6); // 生成一个1到6（包含）之间的整数
    let rand_increment:f64=rng.sample(rand_distr::StandardNormal); //生成正态分布的随机数
}

```

# 二分查找

`partition_point`方法是实现 `lower_bound`和 `upper_bound`功能最直接和推荐的方式。它接收一个谓词（返回 `bool`的闭包），并返回切片中**第一个使该谓词返回 `false`**的元素的索引

## 类似C++的lower_bound

查找第一个**大于等于**目标值的元素位置。

谓词条件是判断元素是否**小于**目标值。返回的位置就是第一个“不小于”（即大于等于）目标值的位置

```rust
let nums = vec![1, 2, 3, 3, 4];
let target = 3;

// 查找第一个 >= target 的元素的位置 (lower_bound)
let lower = nums.partition_point(|&x| x < target);
println!("Lower bound of {} is at index: {}", target, lower); // 输出 2
```

## 类似C++的upper_bound

```rust
// 查找第一个 > target 的元素的位置 (upper_bound)
let upper = nums.partition_point(|&x| x <= target);
println!("Upper bound of {} is at index: {}", target, upper); // 输出 4
```

## 插入操作

```rust
let j = g.partition_point(|&x| x < h);
if j < g.len() {
    g[j] = h;
} else {
    g.push(h);
}
```



# sort_by按条件排序

`sort_by(|a, b| ...)`中的闭包，其核心任务是回答一个问题：**相对于 `a`，`b`的顺序是什么？**或者更直白地说：**在最终的排序结果中，`b`应该出现在 `a`的前面还是后面？**

- 当闭包返回 `Ordering::Less`时，表示第一个参数（a）应该排在第二个参数(b)**之前**。
- 在 `a.cmp(b)`中，如果 `a`小于 `b`，则返回 `Less`，所以 `a`会排在 `b`前面，形成递增。
- 在 `b.cmp(a)`中，如果 `b`小于 `a`，则返回 `Less`，所以 `a`会排在 `b`前面，这相当于把大的数往前放，形成递减。

所以，整个代码 `tasks.sort_by(|a, b| b.cmp(a))`的工作流程是：

1. 排序算法每次取出集合中的两个元素，分别作为闭包的参数 `a`和 `b`。
2. 闭包执行 `b.cmp(a)`，也就是判断 **`b`相对于 `a`的顺序**。
3. 如果 `b`比 `a`大（即 `b.cmp(a)`返回 `Ordering::Greater`），排序算法就会认为 `a`应该排在 `b`的后面，从而实现了**从大到小**的降序排列。

```rust
let mut v = [5, 4, 1, 3, 2];
// 降序排序
v.sort_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]); // 结果是从大到小
```

# 结构体排序

```rust
//envelopes: mut Vec<Vec<i32>>
envelopes.sort_unstable_by_key(|e| (e[0], -e[1]));
```

# 最小堆的实现
rust的BinaryHeap默认实现最大堆，如果要建立最小堆，可以使用 Reverse 包装器，std::cmp::Reverse 是一个简单的包装器结构体，它会反转其内部值的排序顺序。
## 原理
当你将一个元素 T 包装在 Reverse<T> 中时，Reverse<T> 的 Ord 实现会调用 T 的 Ord 实现，但会返回相反的结果。
a.cmp(b) 返回 Ordering::Less，那么 Reverse(a).cmp(&Reverse(b)) 就会返回 Ordering::Greater。
这样一来，BinaryHeap 在比较 Reverse 元素时，就会把最小的原始元素当成 “最大” 的 Reverse 元素，从而将其放在堆顶。
## 实现
```rust

use std::collections::BinaryHeap;
use std::cmp::Reverse;

fn main() {
    // 创建一个存储 Reverse<i32> 的 BinaryHeap
    let mut min_heap = BinaryHeap::new();

    // 插入元素时，用 Reverse 包装起来
    min_heap.push(Reverse(3));
    min_heap.push(Reverse(1));
    min_heap.push(Reverse(2));

    println!("最小堆弹出顺序：");
    while let Some(Reverse(num)) = min_heap.pop() {
        println!("{}", num); // 输出顺序：1, 2, 3
    }
}

```

```rust
//用最小堆实现霍夫曼树
use std::collections::BinaryHeap;
use std::cmp::Reverse;
impl Solution {
    pub fn min_build_time(blocks: Vec<i32>, split: i32) -> i32 {
        let n=blocks.len();
        let mut pqu=BinaryHeap::new();
        for i in 0..n{
            pqu.push(Reverse(blocks[i]));
        }
        while pqu.len()>1{
            let a=pqu.pop().unwrap().0;
            let b=pqu.pop().unwrap().0;
            pqu.push(Reverse(split+std::cmp::max(a,b)));
        }
        pqu.pop().unwrap().0
    }
}

```
# 闭包
+ Fn闭包
  通过==引用==捕获变量，不可变借用。
+ FnMut闭包
  通过==可变引用==捕获变量，可变借用。
+ FnOnce闭包
  通过==值==捕获变量，所有权转移。

```rust
fn main(){
    let x=5;
    let y=10;

    //Fn闭包：通过引用捕获变量
    let add = |a| a+x;

    //FnMut闭包：通过可变引用捕获变量
    let mut multiply = |a|{
        a/y
    };

    //FnOnce闭包：通过值捕获变量
    let divide = move |a|{
    a/y
    };
}

```

# 多线程
## spawn创建线程
```rust
use std::{thread,time::Duration,Builder};

fn main(){
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    //Thread也支持通过std::thread::Builder结构体进行创建，Builder提供了一些线程的配置项

    let handle=Builder::new()
        .name("my_thread".to_string()) //线程名
        .stack_size(1024*4)    //设置线程的堆栈大小是1024*4
        .spawn({
            "hello world" //相当于子线程的执行结果就是字符串"hello world"
        });
    let res=handle.join().unwrap();  //阻止当前线程（主线程）执行，等待子线程执行完毕，得到子线程的执行结果，即"hello world"

}


```
线程中使用了其他线程的变量是不合法的，必须使用move表明线程拥有data的所有权，我们可以使用move关键字把data的所有权转移到子线程内。
```rust
use std::thread;

fn main(){
    let data=String::from("hello world");
    let thread=std::thread::spawn(move ||{  //使用move把data的所有权转到线程内
        println!("{}",data);
    });
    thread.join();

    let v=vec![1,3,5,7,9];
    let mut childs=vec![];
    for n in v{
        let c=thread::spawn(move ||{
            println!("{}",n*n);
        });
        childs.push(c);
    }
    for c in childs{
        c.join().unwrap();  //等待所有子进程结束，或者使用expect方法来获取返回值
    }
}

```
move闭包通常和thread::spawn函数一起使用，它允许用户使用其他线程的数据，这样在创建新线程时，可以把其他线程中的变量的所有权从一个线程转移到另一个线程，然后就可以使用改变量了。
## 得到当前系统的默认并行度
```rust
use std::{io,thread};
fn main() ->io::Result<()>{
    let count=thread::available_parallelism()?.get();
    assert!(count>=1_usize);
    println!("{},{}",count,1_usize);
    Ok(())
}
```
## 线程间通信
```rust

use std::sync::{Arc,Mutex};
use std::thread;

fn main() {
    let counter=Arc::new(Mutex::new(0));
    let mut handles=vec![];

    for _ in 0..10{
        let counter=Arc::clone(&counter);
        let handle=thread::spawn(move||{
            let mut num=counter.lock().unwrap();
            *num+=1;
        });
        handles.push(handle);
    }

    for handle in handles{
        handle.join().unwrap();
    }

    println!("result: {}",*counter.lock().unwrap());
}

```

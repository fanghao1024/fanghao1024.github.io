# P2.1

根据您上传的图片，我将解答这两道关于数值分析的VBA编程练习题。解答包括为每个题目编写VBA子程序代码，并分析当 N→∞时平方和 ∑i=1N[ΔX(ti)]2的极限行为。以下是详细解答。

### 2.1 题：函数 X(t)=et

以下rust代码会提示用户输入 T和 N，计算平方和，并输出结果。

```rust
use std::io;

// 2.1 题：函数 X(t) = e^t
fn calculate_sum_exp() {
    println!("计算函数 X(t) = e^t 的平方和");
    
    // 获取用户输入
    let t = get_user_input("请输入 T 的值: ");
    let n = get_user_input("请输入 N 的值: ") as usize;
    
    if n == 0 {
        println!("错误：N 不能为 0");
        return;
    }
    
    let dt = t / n as f64;
    let mut sum = 0.0;
    
    // 计算平方和
    for i in 1..=n {
        let t_i = i as f64 * dt;
        let t_im1 = (i - 1) as f64 * dt;
        let delta_x = t_i.exp() - t_im1.exp();
        sum += delta_x * delta_x;
    }
    
    println!("函数 X(t) = e^t 的平方和为: {:.6}", sum);
    
    // 分析极限行为
    let theoretical_limit = 0.0;
    println!("当 N → ∞ 时，理论极限为: {}", theoretical_limit);
}

// 2.2 题：函数 X(t) = t^3
fn calculate_sum_cubic() {
    println!("计算函数 X(t) = t^3 的平方和");
    
    // 获取用户输入
    let t = get_user_input("请输入 T 的值: ");
    let n = get_user_input("请输入 N 的值: ") as usize;
    
    if n == 0 {
        println!("错误：N 不能为 0");
        return;
    }
    
    let dt = t / n as f64;
    let mut sum = 0.0;
    
    // 计算平方和
    for i in 1..=n {
        let t_i = i as f64 * dt;
        let t_im1 = (i - 1) as f64 * dt;
        let delta_x = t_i.powi(3) - t_im1.powi(3);
        sum += delta_x * delta_x;
    }
    
    println!("函数 X(t) = t^3 的平方和为: {:.6}", sum);
    
    // 分析极限行为
    let theoretical_limit = 0.0;
    println!("当 N → ∞ 时，理论极限为: {}", theoretical_limit);
}

// 辅助函数：获取用户输入
fn get_user_input(prompt: &str) -> f64 {
    loop {
        println!("{}", prompt);
        
        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .expect("读取输入失败");
        
        match input.trim().parse() {
            Ok(value) if value >= 0.0 => return value,
            Ok(_) => println!("请输入一个非负数"),
            Err(_) => println!("请输入有效的数字"),
        }
    }
}

// 主函数
fn main() {
    println!("数值分析计算程序");
    println!("1. 计算函数 X(t) = e^t");
    println!("2. 计算函数 X(t) = t^3");
    println!("请选择要计算的函数 (1 或 2): ");
    
    let mut choice = String::new();
    io::stdin()
        .read_line(&mut choice)
        .expect("读取输入失败");
    
    match choice.trim() {
        "1" => calculate_sum_exp(),
        "2" => calculate_sum_cubic(),
        _ => println!("无效选择，请输入 1 或 2"),
    }
}

// 测试模块
#[cfg(test)]
mod tests {
    use super::*;
    
    // 测试平方和计算
    fn calculate_sum_exp_test(t: f64, n: usize) -> f64 {
        let dt = t / n as f64;
        let mut sum = 0.0;
        
        for i in 1..=n {
            let t_i = i as f64 * dt;
            let t_im1 = (i - 1) as f64 * dt;
            let delta_x = t_i.exp() - t_im1.exp();
            sum += delta_x * delta_x;
        }
        sum
    }
    
    fn calculate_sum_cubic_test(t: f64, n: usize) -> f64 {
        let dt = t / n as f64;
        let mut sum = 0.0;
        
        for i in 1..=n {
            let t_i = i as f64 * dt;
            let t_im1 = (i - 1) as f64 * dt;
            let delta_x = t_i.powi(3) - t_im1.powi(3);
            sum += delta_x * delta_x;
        }
        sum
    }
    
    #[test]
    fn test_exp_function() {
        let result = calculate_sum_exp_test(1.0, 1000);
        assert!(result > 0.0);
        assert!(result < 1.0); // 对于光滑函数，平方和应该很小
    }
    
    #[test]
    fn test_cubic_function() {
        let result = calculate_sum_cubic_test(1.0, 1000);
        assert!(result > 0.0);
        assert!(result < 1.0);
    }
    
    #[test]
    fn test_convergence() {
        // 测试当 N 增大时，平方和趋近于 0
        let t = 1.0;
        let n1 = 100;
        let n2 = 1000;
        let n3 = 10000;
        
        let result1 = calculate_sum_exp_test(t, n1);
        let result2 = calculate_sum_exp_test(t, n2);
        let result3 = calculate_sum_exp_test(t, n3);
        
        // 随着 N 增大，平方和应该减小
        assert!(result1 > result2);
        assert!(result2 > result3);
    }
}
```

#### 极限行为分析当 N→∞

当 N→∞时，时间步长 Δt=T/N趋近于 0。平方和 $∑_{i=1}^N[ΔX(t_i)]^2$的极限行为如下：

- 对于函数 $X(t)=e^t$，差分$ ΔX(t_i)=e^{t_i}−e^{t_{i−1}}$。当 Δt很小时，$ΔX(t_i)≈e^{t_i}Δt$，因此 $[ΔX(t_i)]^2≈e^{2t_i}(Δt)^2$。

- 平方和近似为 $∑_{i=1}^Ne^{2t_i}(Δt)^2=Δt∑_{i=1}^Ne^{2t_i}Δt$。当 N→∞时，$∑_{i=1}^Ne^{2t_i}Δt$趋近于积分 $\int_0^Te^{2t}dt=\frac{e^{2T}−1}{2}$，但整体平方和乘以 Δt，因此：
  $$
  \sum_{i=1}^{N}[\Delta X(t_i)]^2 \approx \Delta t \cdot \frac{e^{2T}−1}{2}  \rightarrow0 ,\text{when } N\rightarrow \infty 
  $$
  

- 精确计算也可得：

  1. **定义差分**：

     首先，时间区间 [0,T]被等分为 N个子区间，步长 Δt=T/N，时间点$t_i=iΔt$。

     差分 $ΔX(t_i)=X(t_i)−X(t_{i−1})=e^{t_i}−e^{t_{i−1}}$。

     由于 $t_i=iΔt$和 $t_{i−1}=(i−1)Δt$，有：
     $$
     ΔX(t_i)=e^{iΔt}−e^{(i−1)Δt}=e^{(i−1)Δt}(e^{Δt}−1).
     $$

  2. **计算平方**：

     每个差分的平方为：
     $$
     [ΔX(t_i)]^2=[e^{(i−1)Δt}(e^{Δt}−1)]^2=(e^{Δt−1})^2e^{2(i−1)Δt}
     $$
     

  3. **求和**：

     平方和 S是所有差分的平方和：
     $$
     S=∑_{i=1}^N[ΔX(t_i)]^2=∑_{i=1}^N(e^{Δt}−1)^2e^{2(i−1)Δt}=(e^{Δt}−1)^2∑_{i=1}^Ne^{2(i−1)Δt}.
     $$
     

     注意，求和索引 i从 1 到 N，对应指数 k=i−1从 0 到 N−1，因此：
     $$
     ∑_{i=1}^Ne^{2(i−1)Δt}=∑_{k=0}^{N−1}(e^{2Δt})^k
     $$
     

     这是一个几何级数，公比$ r=e^{2Δt}$。几何级数求和公式为：
     $$
     ∑_{k=0}^{N−1}r^k=\frac{1−r^N}{1−r},当 r\neq 1
     $$
     代入 $r=e^{2Δt}$，且 $r^N=e^{2NΔt}=e^{2T}$（因为 NΔt=T)，得：
     $$
     ∑_{k=0}^{N−1}r^k=\frac{1−e^{2T}}{1−e^{2Δt}}
     $$
     

  4. **最终表达式**：

     因此，平方和 S的精确值为：
     $$
     S=(e^{Δt}−1)^2\cdot\frac{1−e^{2T}}{1−e^{2Δt}}
     $$
     

     这个表达式是精确的，适用于任何 N和 T。当 N→∞时，Δt→0，可以利用泰勒展开分析极限行为，但上述公式给出了有限 N下的精确值。

  平方和 $S=(e^{Δt}−1)^2\cdot\frac{1−e^{2T}}{1−e^{2Δt}}$，当 Δt→0时，利用近似$ e^{Δt}−1≈Δt$和 $1−e^{2Δt}≈−2Δt$，有 $S≈Δt⋅\frac{e^{2T}−1}{2}→0$。

因此，当 N→∞时，平方和趋近于 0。

# P2.2

2.2 题：函数 X(t)=t3



# P2.3

### 理论分析

布朗运动（Brownian motion）是一种随机过程，其路径连续但不可微。关键性质是：

- 布朗运动的增量$ ΔB(t_i)=B(t_i)−B(t_{i−1})$是独立随机变量，服从正态分布 N(0,Δt)，其中 Δt=T/N是时间步长。
- 每个增量$ ΔB(t_i)$的均值为0，方差为 Δt。

现在考虑绝对值 $∣ΔB(t_i)∣$。这是一个半正态分布（half-normal distribution）变量。其期望值为：
$$
\mathbb{E}[|\Delta B(t_i)|]=\sqrt{\frac{2}{\pi}}\sqrt{\Delta t}=\sqrt{\frac{2}{\pi}}\sqrt{\frac{T}{N}}
$$

> 推导$ E[∣ΔB(t_i)∣]$
>
> 1. **布朗运动增量的分布**
>
>    布朗运动的关键性质是，其增量 $ΔB(t_i)=B(t_i)−B(t_{i−1})$服从均值为0、方差为 Δt=T/N的正态分布：
>    $$
>    ΔB(t_i)∼N(0,Δt)
>    $$
>    我们可以将其标准化，令 $Z=\frac{ΔB(t_i)}{\sqrt{\Delta t}}$，则 Z是一个标准正态随机变量，即 Z∼N(0,1)。因此，有 $ΔB(t_i)=Z⋅\sqrt{Δt}$。
>
> 2. **计算绝对值的期望**
>
>    我们要求的是$ ∣ΔB(t_i)∣$的期望值：
>    $$
>    E[∣ΔB(t_i)∣]=E[∣Z⋅\sqrt{Δt}∣]=\sqrt{Δt}⋅E[∣Z∣]
>    $$
>    
>
>    这里，我们将常数因子$\sqrt{Δt}$提到了期望算子外面。现在，问题转化为计算标准正态随机变量 Z的绝对值的期望值 E[∣Z∣]。
>
> 3. **计算 E[∣Z∣]（标准正态分布绝对值的期望）**
>
>    E[∣Z∣]可以通过对标准正态分布的概率密度函数（PDF）进行积分来求得。标准正态分布的PDF为：
>    $$
>    ϕ(z)=\frac{1}{\sqrt{2π}}e^{\frac{−z^2}{2}}
>    $$
>    
>
>    根据期望值的定义：
>    $$
>    E[|Z|]=\int^{\infty}_{-\infty}|z|\cdot \phi(z)dz
>    $$
>    因为函数 ∣z∣ϕ(z)是偶函数（关于y轴对称），我们可以简化这个积分：
>    $$
>    E[|Z|]=2\int^{\infty}_{0}z\cdot \phi(z)dz
>    $$
>    
>
>    将 ϕ(z)代入：
>    $$
>    E[|Z|]=2\int^{\infty}_{0}z\cdot \frac{1}{\sqrt{2π}}e^{\frac{−z^2}{2}}dz=\sqrt{\frac{2}{\pi}}\int^{\infty}_{0}z e^{-\frac{z^2}{2}}dz
>    $$
>    
>
> 4. **求解积分**
>
>    这个积分可以通过换元法求解。令 $u=z^2/2$，则 du=zdz。当 z=0时，u=0；当 z→∞时，u→∞。
>    $$
>    \int^{\infty}_{0}z e^{-\frac{z^2}{2}}dz=\int^{\infty}_{0}e^{-u}du=[-e^{-u}]_0^{\infty}=0-(-1)=1
>    $$
>    
>
>    因此，
>    $$
>    E[|Z|]=\sqrt{\frac{2}{\pi}}\cdot 1=\sqrt{\frac{2}{\pi}}
>    $$
>    
>
> 5. **得到最终结果**
>
>    将 E[∣Z∣]的结果代回第二步的等式中：
>    $$
>    E[∣ΔB(t_i)∣]=Δt⋅E[∣Z∣]=\sqrt{Δt}⋅\sqrt{\frac{2}{π}}=\sqrt{\frac{2\Delta t}{π}}
>    $$
>    由于 Δt=T/N，所以最终表达式为：
>    $$
>    E[∣ΔB(t_i)∣]=\sqrt{\frac{2\Delta t}{π}}
>    $$
>    
>
> ### 结论总结
>
> - **单个增量的绝对值期望**：$E[∣ΔB(t_i)∣]=\sqrt{\frac{2T}{π N}}$。
> - 
>
> 这个计算过程的核心在于识别出增量分布并利用标准正态分布绝对值的期望这个经典结论。

**N个增量绝对值和的期望**：利用期望的线性性质，总和 $S_N=∑_{i=1}^N∣ΔB(t_i)∣$的期望为：
$$
E[S_N]=∑_{i=1}^NE[∣ΔB(t_i)∣]=N⋅\sqrt{\frac{2T}{π N}}=\sqrt{\frac{2T}{π}}\cdot \sqrt{N}
$$


**当 N→∞时**：由于 $E[S_N]$与 N成正比，当分割数 N趋于无穷大时，这个和 SN的期望值也趋于无穷大。这证明了布朗运动的路径具有**无限的一阶变差**。

进一步，SN的方差为：
$$
Var(S_N)=∑_{i=1}^NVar(∣ΔB(t_i)∣)=N⋅Δt(1−\frac{2}{π})=T(1−\frac{2}{π}),
$$

> 根据方差的定义：
> $$
> Var(∣ΔB(t_i)∣)=E[∣ΔB(t_i)∣^2]−(E[∣ΔB(t_i)∣])^2
> $$
> 我们的目标是计算出等号右边的两个期望值，然后相减。
>
> ### 第一步：计算 $E[∣ΔB(t_i)∣^2]$
>
> 这是一个关键的简化步骤。因为对一个数先取平方再取绝对值，等价于直接取平方（平方运算总会产生非负的结果，所以绝对值符号是冗余的）：
> $$
> ∣ΔB(t_i)∣^2=(ΔB(t_i))^2
> $$
> 
>
> 因此，
> $$
> E[∣ΔB(t_i)∣^2]=E[(ΔB(t_i))^2]
> $$
> 
>
> 我们知道，布朗运动的增量 $ΔB(t_i)=B(t_i)−B(t_{i−1})$服从正态分布，其均值为 0，方差为时间间隔 $Δt=t_i−t_{i−1}=T/N$：
> $$
> ΔB(t_i)∼N(0,Δt)
> $$
> 对于一个均值为 μ，方差为 $σ^2$的随机变量 X，其二次矩的公式为：
> $$
> E[X^2]=Var(X)+(E[X])^2
> $$
> 
>
> 将其应用到我们的情况中，其中$ X=ΔB(t_i), μ=0, σ^2=Δt$：
> $$
> E[(ΔB(t_i))^2]=Var(ΔB(t_i))+(E[ΔB(t_i)])^2=Δt+0^2=Δt
> $$
> 所以，我们得到：
> $$
> E[∣ΔB(t_i)∣^2]=Δt
> $$
>
> ### 第二步：计算$ E[∣ΔB(t_i)∣]$
>
> 由前面的计算过程，可知：
> $$
> E[∣ΔB(t_i)∣]=\sqrt{\frac{2\Delta t}{π}}
> $$
> 
>
> ### 第三步：代入方差公式进行计算
>
> 现在我们将第一步和第二步的结果代入方差的定义式中：
> $$
> \begin{align}
> Var(∣ΔB(t_i)∣)&=E[∣ΔB(t_i)∣^2]−(E[∣ΔB(t_i)∣])^2\\
> &=\Delta t-(\sqrt{\frac{2\Delta t}{π}})^2\\
> &=\Delta t - \frac{2\Delta t}{\pi}\\
> &=\Delta t(1-\frac{2}{\pi})
> \end{align}
> $$

其中$ Var(∣ΔB(t_i)∣)=Δt(1−2/π)$。方差是常数，不依赖于 N。

由于 $E[S_N]$发散而方差有界，根据大数定律，当 N→∞时，和 SN本身几乎必然发散到无穷大。这与布朗运动的路径性质一致：布朗运动具有无限的一阶变差（infinite first variation），而二次变差有限（如题目2.3中平方和收敛到 T）。

### 结论

当 N→∞时，绝对值和$ ∑_{i=1}^N∣ΔB(t_i)∣$发散到无穷大。这意味着随着分割数增加，绝对值的和会无限增长，与平方和的行为截然不同。